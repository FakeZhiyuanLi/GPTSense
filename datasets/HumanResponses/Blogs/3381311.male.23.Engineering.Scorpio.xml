<Blog>

<date>25,May,2004</date>
<post>

     
      SAN JOSE, Calif., May 25, 2004 - Cisco Systems, Inc., today announced the Cisco® CRS-1 Carrier Routing System, a new class of routing system designed to deliver continuous system operation, service flexibility and extended system longevity to telecommunications service providers and research organizations. This innovative routing system helps enable customers to scale network capacity to new levels and deliver next-generation data, voice and video services over a converged Internet Protocol (IP) network while protecting their investments in the system.  "The Cisco CRS-1 is a result of Cisco's partnership with our service provider customers to redefine how next-generation IP networks are built to deliver data, voice and video applications," said Mike Volpi, senior vice president/general manager, Routing Technology Group, Cisco Systems®. "To be profitable, service providers are focusing on network and service convergence to reduce total cost of ownership, and adding new, revenue-generating services. The Cisco CRS-1 sets new industry standards for reliability, IP service flexibility and scalability, which will enable service providers to become more cost-efficient while delivering a new suite of exciting, multimedia services to business and residential customers."  The Cisco CRS-1 comprises a series of new hardware and software innovations that include:  Cisco IOS® XR Software, a new member of the Cisco IOS Software family, designed for terabit-scale routing systems built on massively distributed multi-shelf architectures  System capacity of up to 92 terabits per second (Tbps)  Industry's first Optical Carrier (OC)-768c/STM-256c packet interface  Cisco Silicon Packet Processor (SPP), the world's most sophisticated 40-Gbps application-specific integrated circuit (ASIC)  Extensible Markup Language (XML)-based Cisco Craft Works Interface (CWI), a visual management tool that can manage single-shelf or multishelf systems.  The Cisco Intelligent ServiceFlex design for service flexibility and speed to service  With its technology breakthroughs and industry-leading performance, the Cisco CRS-1 enables reliable, large-scale delivery of high-bandwidth applications, including video on demand, online gaming, and real-time interactive services.  "As a leading carrier of data and voice worldwide, Sprint diligently works to ensure its network can meet growing service and capacity needs in a cost-effective manner, which is why we were excited to provide insight into the Cisco CRS-1 design early on," said Kathy Walker, executive vice president, Network Services, at Sprint. "Some key benefits a core routing system such as the Cisco CRS-1 will provide are flexibility, scalability and modular design, which will help to simplify network management and allow for efficient growth based on network needs."  Continuous System Operation The Cisco CRS-1 provides continuous system operation, permitting maintenance and upgrades without any service interruptions. This unique fault-tolerance capability is achieved through Cisco IOS XR Software, the industry's only self-healing operating system for multishelf carrier infrastructures scaling up to 92 Tbps. The memory-protected, microkernel-based operating system enables process-level in-service upgrades, and enables fully distributed processing by separating of the control, data and management planes. This modular design provides fault containment and automatic fault recovery so that processes can be started, stopped and upgraded without human intervention. In addition, the Cisco CRS-1 features self-defending network capabilities to automatically recognize disruptive activities, such as distributed-denial-of-service (DDoS) attacks, with hardware- and software-based infrastructure.  The Cisco CRS-1 features operationally efficient system management through command-line-interface (CLI) enhancements, Simple Network Management Protocol (SNMP) or XML-based interfaces. The new XML-based Craft Works Interface (CWI) is a visual management tool that can manage single-shelf or multishelf systems.  "As one of the leading carriers in Europe, T-Com makes sure that our core infrastructures are future-proof and able to implement IP/MPLS services onto a highly available and flexible IP-based network," said Wolfgang Schmitz, senior executive vice president for technical engineering at T-Com, Deutsche Telekom's fixed-network division. "This strategy will enable us to enhance operational efficiency and optimize profitability. The Cisco CRS-1 system offers new levels of scalability and innovation as a foundation for our next-generation IP services."   Advanced Service Flexibility The Cisco CRS-1 is built with a unique service-separation architecture—the Cisco Intelligent ServiceFlex design—that separates traffic and network operations on a per-service or per-customer basis within the system. This system design allows carriers to quickly adapt to changing customer needs and accelerate service delivery by combining the Cisco Silicon Packet Processor (SPP), the world's most sophisticated 40-GbpsASIC, and Cisco IOS XR Software. With comprehensive service separation and line-rate feature flexibility, the Cisco CRS-1 allows carriers to consolidate multiple networks onto one secure infrastructure and deliver converged network services.  Extended System Longevity The Cisco CRS-1 is a nonblocking, self-routed multishelf system that scales from 1.2 to 92 Tbps. The system features the industry's first OC-768c/STM-256c IP interface and supports up to 1152 40-Gbps line-card slots. System processes such as Border Gateway Protocol (BGP) and Multiprotocol Label Switching (MPLS) can also be fully distributed across the routing system for maximum efficiency and scale. The system scalability of the Cisco CRS-1 reduces total cost of ownership by simplifying today's networks while protecting investments in capital equipment.  During a product-unveiling event today hosted by Cisco at the Computer History Museum in Mountain View, Calif., MCI, using Cisco CRS-1 systems, demonstrated the fastest IP intercity transmission ever across MCI's IP backbone at 40-Gbps throughput.  "Our mission is to serve our customers and help them realize the enormous benefits of MCI's global IP network," said Jonathan Crane, chief strategy officer, MCI. "The promise of a high-capacity router complements our ultra-long-haul network strategy designed to meet the increasing capacity needs of our customers as they move to a digital, IP environment."  "Pittsburgh Supercomputing Center is a major participant in TeraGrid, the National Science Foundation's program to deploy an advanced integrated cyber infrastructure for scientific research," said Gwendolyn Huntoon, Pittsburgh Supercomputing Center (PSC) director of networking. "Having installed the Cisco CRS-1 to manage PSC's TeraGrid connection, we're confident this platform is the best routing system to meet our requirements now and in the foreseeable future."  PSC is an associate of the National Lambda Rail (NLR), which provides advanced network services to a number of leading-edge research institutions and agencies. "The NLR also plans to deploy Cisco CRS-1 systems in its national backbone as the foundation to enable ongoing technology innovation through advanced networking and scientific experimentation," said Tracy Futhey, NLR Board Chair and CIO of Duke University.  The Cisco CRS-1 complements Cisco's existing portfolio of routers that support the world's largest carrier and enterprise networks. The new routing system is the result of Cisco's proven 20-year track record in routing innovations through focused research and development programs. The Cisco CRS-1 provides carriers with high-performance core routing capabilities, and rounds out Cisco's existing carrier-class routing portfolio, which is ideally suited to deliver cost effective and innovative IP services. For information about the Cisco CRS-1 Carrier Routing System and Cisco's high-end routing strategy for customers, visit: www.cisco.com/go/crs/  Availability and Pricing The Cisco CRS-1 is currently in field trials now with carriers and service providers worldwide and is scheduled to be available in July 2004. The starting system list price is $450,000 USD.  
     
    
</post>

<date>18,May,2004</date>
<post>

     
      /*------------------------------------------------------------------  * ipv6_discovery_test.c -- Neighbor Discovery unit tests.  *  * August 2003, Ole Troan  *  * Copyright (c) 2003-2004 by cisco Systems, Inc.  * All rights reserved.  *------------------------------------------------------------------  */  #include "interface.h"  #include "interface_private.h"  #include "../ipv6.h"  #include "../ipv6_discovery.h"  #include "sys_registry.h"  #include "subsys.h"  #include COMP_INC(cutest, cu_test.h)   idbtype lidb;  hwidbtype hwidb;  ipv6_idbtype ipv6_sb;  in6_addr_t target;   /*  * setup_subsys_init  */  extern list_header subsyslist[SUBSYS_CLASS_MAX];  static void  setup_subsys_init (subsys_class category, char *name)  {  list_element *element;  subsystype *subsys;   FOR_ALL_DATA_IN_LIST(&subsyslist[category], element, subsys) {  if (!strcmp(name, subsys->namestring)) {  if (subsys->entry) {  (*subsys->entry)(subsys);  break;  }  }  }  }    static void  setup (void) {  setup_subsys_init(SUBSYS_CLASS_PROTOCOL, "ipv6_nd");  reg_add_printf((long)'P', ipv6_printf, "ipv6_printf");   /*  * Create an IDB and Enable IPv6 on it  */  lidb.hwptr = &hwidb;  hwidb.firstsw = &lidb;  hwidb.status = IDB_ETHER;  lidb.ipv6_data = &ipv6_sb;   target.s6_addr32[0] = 0x2001000;  target.s6_addr32[3] = 0x0000001;  }    /*  * nd_test_create  */  CU_TEST_START (nd_test_create, tc)  {  ipv6_nd_entry *e;   printf("\nAdding %P to ND cache", &target);   e = ipv6_nd_table_create(&target, &lidb);  cu_ok(tc, (e != NULL), "%s", "create ND entry");  cu_ok(tc, (e->idb == &lidb) &&  IN6_ARE_ADDR_EQUAL(&e->address, &target), "%s",  "verify ND entry");  }  CU_TEST_END    /*  * nd_test_lookup  */  CU_TEST_START (nd_test_lookup, tc)  {  ipv6_nd_entry *e;   e = ipv6_nd_table_lookup(&target, &lidb);  cu_ok(tc, (e != NULL), "%s", "ND lookup");  }  CU_TEST_END    /*  * nd_test_delete  */  CU_TEST_START (nd_test_delete, tc)  {  ipv6_nd_entry *e;   ipv6_nd_table_delete(&target, &lidb);  e = ipv6_nd_table_lookup(&target, &lidb);  cu_ok(tc, (e == NULL), "ND delete");  }  CU_TEST_END    /*  * nd_test_suite  */  cu_suite_t *  nd_test_suite (void)  {  cu_suite_t *s = cu_suite_new();   CU_SUITE_ADD_TEST(s, nd_test_create);  CU_SUITE_ADD_TEST(s, nd_test_lookup);  CU_SUITE_ADD_TEST(s, nd_test_delete);   return (s);  }    CU_TEST_MAIN()  {  int res;  cu_suite_t *suite = cu_suite_new();   cu_init();  cu_suite_add_suite(suite, nd_test_suite());  setup();  res = cu_suite_run(suite);  cu_suite_summary(suite);   CU_TEST_MAIN_RETURN(res);  } 
     
    
</post>

<date>18,May,2004</date>
<post>

     
      /*------------------------------------------------------------------  * ipv6_tcp.c -- IP version 6 support functions for TCP  *  * June 1996, Kirk Lougheed  *  * This should be the only file in the TCP sources that  * explicitly references an IPv6 header or IPv6 addresses.  *  * Copyright (c) 1996-2003 by cisco Systems, Inc.  * All rights reserved.  *------------------------------------------------------------------  */   #include "master.h"  #include "address.h"  #include "packet.h"  #include "interface_private.h"  #include "../ipv6/ipv6.h"  #include "../ipv6/ipv6_private.h"  #include "../ipv6/ipv6_stats.h"  #include "../ipv6/ipv6_idb.h"  #include "icmp6.h"  #include "ipv6_debug.h"  #include "../tcp/tcp.h"  #include "../tcp/tcpinternal.h"  #include "../tcp/tcp_debug.h"    /*  * ipv6_receive_tcp_header  *  * Pass a TCP segment to the main TCP layer.  * We checksum it and set up private pointers.  */  void  ipv6_receive_tcp_header (paktype *pak)  {  ip6_hdr_t *ip;  tcptype *tcp;  ipv6addr_listtype *ifa;   /*  * Checksum the TCP packet.  * Errors are counted by the IPv4 code.  */  ip = (ip6_hdr_t *)pak->network_start;  tcp = (tcptype *)pak->transport_start;   /*  * Don't accept TCP connections to multicast or anycast addresses  */  ifa = ipv6_address_find(pak->if_input, &ip->ip6_dst);  if ((ifa && (ifa->flags & IPV6_IFF_ANYCAST)) ||   IN6_IS_ADDR_MULTICAST(&ip->ip6_dst)) {  if (tcp_debug)   buginf("\nTCP: anycast or multicast address    ",    &ip->ip6_src, tcp->sourceport,   &ip->ip6_dst, tcp->destinationport);   retbuffer(pak);   return;  }   if (ipv6_checksum(ip, tcp, IPPROTO_TCP)) {  if (tcp_debug)  buginf("\nTCP: checksum failure    ",    &ip->ip6_src, tcp->sourceport,   &ip->ip6_dst, tcp->destinationport);   tcp_traffic.checksumerr++;   ipv6_stats_update_idb(IPV6_STATS_TCP_CHECKSUM_ERROR, pak->if_input);   retbuffer(pak);   return;  }   /*  * Setup TCP's private pointers  * pak->length is total length less IP header bytes (including extensions)  */  pak->dataptr = (uchar *)tcp;  pak->length = ip->ip6_plen + IPV6_HEADERBYTES - ((int)tcp - (int)ip);   /*  * Hand TCP segment off to TCP  */  ipv6_stats_update_idb(IPV6_STATS_TCP_INPUT, pak->if_input);   if (gettcpack(tcp)) {  ipv6_reachable(&ip->ip6_src);  }  tcp_inputsegment(pak);  }    /*  * ipv6_tcp_write  * Write a TCP datagram to network using IPv6 network layer.  *  * Warning: the code that sends a RST about connectionless packets  * calls us with a NULL tcb pointer.  */  void  ipv6_tcp_write (tcbtype * tcb, paktype *pak,    addrtype *destination, addrtype *source)  {  ip6_hdr_t *ip;  tcptype *tcp;  int bytes;   /*  * Put on standard IPV6 header.  * Figure out extension headers some other time.  */  ip = (ip6_hdr_t *)pak->network_start;  ipv6_init_header(ip, IPV6_PRIORITY_INTERACTIVE, IPV6_DEFAULT_FLOW,    pak->length - IPV6_HEADERBYTES, IPPROTO_TCP,    ipv6_hop_limit,   (in6_addr_t *)&source->ipv6_addr,    (in6_addr_t *)&destination->ipv6_addr);   /*  * Compute TCP header checksum  */  tcp = (tcptype *)pak->transport_start;  tcp->checksum = 0;  tcp->checksum = ipv6_checksum(ip, tcp, IPPROTO_TCP);   /*  * Do connection based accounting and fiddling.  */  if (tcb) {  /*   * Do some bean counting  */   if (pak->us_retransno != 0) {  tcp_traffic.retrans++;   tcb->pakoutretrans++;  ipv6_stats_update_idb(IPV6_STATS_TCP_RETRANSMITTED,      pak->if_output);  if (tcppkt_debug)    tcp_print(tcb, pak, tcp, 'R');  } else {  bytes = pak->length - tcp_ipbytes(tcb) + (tcp->dataoffset  if (bytes > 0) {   tcb->bytesoutcount += bytes;   tcb->pakoutdata++;   }  tcb->pakoutcount++;   if (tcppkt_debug)   tcp_print(tcb, pak, tcp, 'O');   }   /*   * We're sending an ACK, so stop the ACK timer   */  tcp_stoptimer(tcb, ACKTIMEOUT);  }   /*  * Write datagram to network.  * Routing is done by IPv6.  */  pak->if_output = NULL;  ipv6_write(pak, IPV6_STATS_TCP_OUTPUT);  }    /*  * ipv6_tcp_icmp_received  *  * We received an ICMP error message about some datagram.  * Check if it is for a TCP packet of ours belonging to an  * active socket. Return TRUE if we absorbed it.  */  boolean  ipv6_tcp_icmp_received (paktype *pak, ip6_hdr_t *ip, icmp6_hdr_t *icmp)  {  tcptype *tcp;  tcbtype *tcb;  addrtype address;   /*  * We are looking for a returned TCP packet inside this ICMP message.  */  tcp = ipv6_icmp_find_ulp(pak, NULL, IPPROTO_TCP);  if (!tcp) {  return (FALSE);  }   /*  * Check that enough of the originating packet was returned  * that we can correctly examine the tcp sport and dport.  * We need everything up to (but not including) the "window" field.  */  if (ip->ip6_plen + IPV6_HEADERBYTES -   ((char *)tcp - (char *)pak->network_start)     ICMPV6_DEBUG("Not enough data returned - dropping packet");  return (FALSE);  }   /*  * Find a matching TCB.  */  ipv6_addrtype_create(&ip->ip6_src, &address);  tcb = find_tcb(GETSHORT(&tcp->destinationport), GETSHORT(&tcp->sourceport),    &address, NULL, FALSE, FALSE, 0);  if (tcb) {  if (icmp->icmp6_type == ICMP6_PACKET_TOO_BIG) {  tcp_pmtu_response(tcb, icmp->icmp6_mtu);   } else if (tcb->state != ESTAB && tcb->state != CLOSEWAIT) {  /*  * Throw away TCBs that applications either don't know  * about or don't care anymore.  */  if ((tcb->flags & TCB_GENTCBS && tcb->state == SYNRCVD) ||  tcb->flags & TCB_APP_CLOSED) {  tcp_async_cleanup(tcb, UNREACHABLE);  } else {  /*  * Application is expected to close the connection  * upon notification of the state change.  */  tcp_deallocatetcb(tcb, UNREACHABLE);  }  }  }  retbuffer(pak);  return (TRUE);  }  
     
    
</post>


</Blog>