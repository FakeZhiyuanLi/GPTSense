<Blog>

<date>21,July,2004</date>
<post>

						
						   Figures. A day after putting out that last post about Java alternatives, I come across  urlLink this  article by Eric Raymond, who comes to the same conclusion, but is much more convincing.   

						
</post>

<date>20,July,2004</date>
<post>

						
						   In my previous post, I described some of the reasons I felt that Java was lacking when using agile development methods. In this article, I'll go over some of the alternatives. Each of these languages has more expressive power than Java, but each has its own particular advantages and disadvantages.    Lisp and Scheme Putting  urlLink Lisp  on this list might be surprising, but it has long been held in esteem by digital cognoscenti. It was, of course, conceived in the fabled early days of computers - one of only handful of programming languages that are older than I am. Despite this, Lisp adherents today assert that it is more powerful than any other language out there. I had spent a few weeks trying to learn Lisp in high school 25 years ago, but never really saw the point of it. My recent interest was sparked after reading several articles in its favor by  urlLink Paul Graham . Lisp, and its more modern cousin,  urlLink Scheme , are blessed with a trivially simple syntax, along with very powerful features such as macros and continuations that take advantage of that simple syntax. There are plenty of packages that extend the language.     So, if Lisp is so great, why hasn't it swept the world by storm. First of all, with dozens of different implementations of Common Lisp, and dozens more of Scheme, the Lisp world appears fragmented. While there appears to be plenty of modules out there for doing things such as HTTP servers, graphics, GUIs, and such, many appear to be specific to some implementation or another. Also, while its support for programming in the small are quite impressive, its not clear that it offers the same advantages for programming in the large. Finally, Lisp's culture of terse and often obscure naming conventions and reliance on tricky, if concise programming techniques probably works against it. Paul Graham argues that, because of the simple syntax, Lisp is easy to learn. The problem is not the syntax, its the concepts. Functional programming, continuations, macro-programming, and recursion as a replacement for loops are all going to be hurdles for the average corporate programmer. Not that these are difficult to learn per-se, just that they are far from the coding mainstream. I may come back to Lisp/Scheme some day, but for now the effort required to assembly the pieces I need, and learn the techniques, is too great.   Python I've been working with  urlLink Python  quite a bit recently, and like it a lot. The syntax is elegant and consistent. It provides metaprogramming facilities. Python also comes with a lot of useful libraries provides everything from HTML and XML parsing, to graphics, to an interface to Tk (Tkinter) for doing GUI applications.   Perl I've never been much of a fan of  urlLink Perl , although I used it extensively in one major project I worked on. It works, but the syntax rules are confusing. In the version I was using (5.6), object-oriented programming was more effort than it should have been. The best thing Perl has going for it is  urlLink CPAN , which serves as a clearinghouse for Perl modules. Its cool because Perl comes with a program for automatically installing modules from CPAN, which makings taking advantage of this resource a snap. One of the reasons I've liked  urlLink jEdit  is the automated installation of plugins. More developers need to do this kind of thing.   Ruby The  urlLink Pragmatic Programmers  recommend  urlLink Ruby  as a great programming language. While it seems a bit less wordy than Python, I don't really see that it has much advantage over that language. urlLink      

						
</post>

<date>02,July,2004</date>
<post>

						
						    The Early Promise  Nearly a decade ago, I slung code in C, C++, and Object Pascal. C was a decent language, if somewhat hard to debug, and it put food on the table. But as I adopted the OOP mind-set, C became less and less appealing. I moved on to C++. It was James Coplien's  urlLink Advanced C++ Programming Styles and Idioms  that really clued me in to both the real advantages of object oriented programming, as well as how best to code C++ classes. But I wondered, why did I have to build all that code for every class? Shouldn't the system be doing that kind of rote coding for me? It seemed to me that C++ always involved a lot more work than it should.   I played a bit with Object Pascal, to be specific, Borland's Delphi product. Object Pascal had automatic memory management, and a much simpler object model than C++. You could whip up a nice, GUI app in no time compared to C++. It was easy. It was fun. Alas, it was also Windows only, and proprietary.  Then, around 1996, came Java. It did objects and managed memory for you. It did cross-platform GUI applications. It came with a great class library. Java seemed perfect. I switched over to java for all my own development Java quickly started accumulating an impressive collection of library classes as Java mind-share grew. Life was good. And it looked like you good actually make a living doing this java stuff to boot! When it came to getting things done, Java was a sailboat to C++'s rowboat. Sure, there were some places you couldn't get to with Java, but for those you could, you could do it with much less effort and a lot more speed and style.   The Decline and Fall  But in the last few years, the sail has started to tatter. I've done some coding in Perl, and marveled at the ease of moving data into and out of methods. I played around a bit with Python, and was impressed with the depth and flexibility of its object model and the cleanness of its syntax. I've struggled with Java APIs that were much more complex than they should have been. I've seen how poor Java has evolved to keep up with changing development techniques. Coding in Java today, I'm beginning to feel the same way I felt 10 years ago coding in C++ - wondering why I need all this extra crap to express what I wanted to. Java was becoming more an anchor than a sail.  Java just doesn't fit my more agile style of development. I do a lot more refactoring and automated unit testing now, and as a result, I've changed sides on the debate between static and dynamic typing. I've seen the work required to get a fairly inflexible language like Java to do things like database persistence well. The increase in computer power has reduced the risk of using interpreted pure object-oriented languages. Short turn-around times has put a premium on developing quick, functional code that doesn't require a lot of extra scaffolding.  The developer community seems to be coming around to this view as well. Those that came to Java from Smalltalk have always complained, of course. At a recent Java conference, there were a lot of complaints about the complexity of enterprise Java, and EJBs in particular. The latest 1.5 version of Java does address some of these concerns. Autoboxing of primitives, for example, is a nice addition, as is variable-length parameter lists. But ultimately, I feel this is too little, too late. I'll still be doing most of my coding in Java, since its paying the rent, but my heart is just not in it anymore. I've come to the conclusion that Java is not part of the best way to develop software. It still has a great class library and unparalleled third-party support, so it will remain a tool in my toolbox. Just not my favorite.  Next... Beyond Java - A look at some alternatives 

						
</post>


</Blog>