<Blog>

<date>27,May,2004</date>
<post>

	 
      Okay, not really "exciting", but eventful in that I didn't do anything that I usually do. On Sunday I went to the Renaissance festival in Fairburn. That was a wonderful day of escapism, and I bought some really cute stuff. :-) All week my schedule at work has been wonky, but the shifts aren't that bad and I've actually been enjoying myself most of the time. It's totally twilight zone to be sure.  For the past two days I've been preparing to go on vacation by revamping my wardrobe :-D, which is very fun. Shopping relieves stress. Try it if you don't believe me. The only problem is that you end up spending lots of money. Fortunately, I rationalize spending so much on clothes by seeing it as an investment. That makes me feel better and gives me a chance to truly appreciate my job, without which I would be broke and couldn't make "investments". ;-)  All in all, I'm looking forward to work today. I'm looking forward to vacation tomorrow even though the Friday exodus will be brutal. It's a 9 hour drive to the place that we're staying, so the trip will be broken up into like 4 or 5 hours on Friday afternoon and the rest of the way Saturday morning with a stop at (hopefully) a nice motel. I so can't wait to see the ocean and walk on the beach. It's been several years since the last time I went on this little family gathering.
     
    
</post>

<date>22,May,2004</date>
<post>

	 
      I should never have cut my hair short in the first place. Now I'm miserable because I can't do anything with it and it looks awful. Hair gel helps, but that's only because I'd rather my hair look bad all day than look bad until a breath of wind catches it and makes it look terrible.  So what can I do? Well, I can get an expensive styling and hope for the best, but the last time I did that it didn't work out well. I could cut it REALLY short, but that would still look bad; it would just be easier to maintain. Or I could just give up and let it look awful until it's long enough to tie back again. For now I'm going with the third choice, but I wouldn't be surprised if in a spat of frustration I went and shaved my head. Then at least I could get looks of sympathy from people who think I have cancer...  Maybe I'll just wear a hat for the next year or so.
     
    
</post>

<date>20,May,2004</date>
<post>

	 
      I think that people must all be on vacation or something. www.cprogramming.com is dead except for a few ongoing threads where the original poster refuses to "get it". IRC isn't hopping much either. I don't feel like programming anything, so I'm pretty much stuck surfing the web trying to find something to do.  What about my friends? Well, they all work during the day, and my shifts are usually at night. Today was my day off, so I just went to the bookstore, had lunch and went home. None of my friends want to go out tonight, so I'm stuck by myself again. When I get bored I lose my train of thought easily. I can't even think of any good way to compose my thoughts, so this blog will be short compared to the others.  Maybe I'll play a game or something...  MEGATOKYO  I finally found volume 1 of Megatokyo at the bookstore today! Good stuff, now I have both of them. Of course, the next one probably won't be out for a long time. Piro isn't well known for doing things quickly. ;-) But that's okay, at least I get my fix of Megatokyo three times a week on average.  CONTEST  I run the contests on www.cprogramming.com. It's a real pain in the butt. I volunteered for the position of contest master some time ago because I had extra time and thought it would be fun. It was fun...for a while. The effort that I had to put into developing a contest, gathering all of the entries and then judging them while under scrutiny of all of the contestants got old very quickly.  I originally planned to run at least one contest a week, but you can imagine how long that lasted. ;-) Now I just don't do anything until somebody asks when the next contest is and I pop up with an idea off the top of my head saying something along the lines of "What a coincidence! I was just finishing this design when you asked." Yes, it's the lazy route and yes people probably hate it, but I've gotten out of my contest master phase.  One of the reasons I've been going to Cprogramming so long is that I don't have any obligation to. It's purely a volunteer effort in my spare time, not a job. If it were a job then I wouldn't want to go and I'd find something else to do. That's why I refused the super-moderator position when they offered it to me. It wouldn't be a job, but it would feel enough like I had to be there that all the fun would be lost.
     
    
</post>

<date>19,May,2004</date>
<post>

	 
      Well, my new book is pretty good for the most part. I did have to ignore the author's fundamental misunderstanding of the relationship between arrays and pointers in C though. He insisted on saying that arrays are "just" constant pointers to a block of memory of size N * sizeof(T). Naturally that's silly. How would the sizeof operator work if this were true? It would return the size of a pointer, not the array as a whole. The fundamental misunderstanding is concerning objects and values. An array in object context, such as an operand of the sizeof or address-of operator, yields the complete object and everything works as it should. Everywhere else is considered a value context, where an array name becomes a pointer to the initial element of the array. So the author's over-simplified stance ends up being very wrong.  I was a bit disappointed by the chapter on memory leaks and debugging them. The author gave good advice, but it was far from complete. It missed some elegance too considering the fact that the book does mention C99. It explained the details of an ugly as sin TRACE/RETURN macro set that looked like this:  const char *LOC; #define TRACE(a) LOC=#a; #define RETURN return; #define RETURN1(a) return(a); #define FILELOC(0) LOC  Now, I'll go through this line by line so that you can see just how terrible this is. The first line creates an externally linked statically allocated variable. The naming scheme is bad because identifiers with all capital names are reserved for macro names by common convention. I don't like the idea of using a global variable without a (very!) good reason either, so I'm a little biased against this use because it could be done better.  The second line creates a trace macro that assigns the stringized contents of the macro argument to LOC. The idea is to save useful information in LOC such as the name of the function being executed at the time. The first thing I noticed is that there's a trailing semicolon. That changes the expected syntax of a function-like macro. Users will correctly try to use it like this:  TRACE(function-name);  But others may safely omit the trailing semicolon to get this:  TRACE(function-name)  And everything will still work properly even though it doesn't look right. I believe that macros should merge as much as possible with the syntax of the rest of the language. If the use of a macro looks awkward or incorrect, it's a poorly designed macro. I also don't think the author really understands how the preprocessor works in C, but I'll get to that in a moment.  The next line defines a RETURN macro that returns a void expression. I can only assume that this is the bare bones macro for something more useful, such as:   /* Blogger sucks, pretend line continuation is there ;-) */ #define RETURN   do {     fprintf(stderr, "Exiting %s\n", LOC);     return;   } while (0) &nbsp   ... Of course, with the author's apparent lack of knowledge when it comes to the preprocessor, it may just be a dumb macro used for symmetry with the TRACE macro. I can understand and relate to the first speculation, but not the second.  The RETURN1 macro is an "overloaded" macro that returns a value from functions instead of a void expression as RETURN does. Since symbol overloading isn't possible with the preprocessor, this is understandable as long as there's a good reason for the return macros.  The last macro is the one that proves the author really doesn't know what's going on. It's a syntax error. A macro identifier list is still and identifier list and requires valid identifiers, which cannot begin with a digit. What the author really wanted was a function-like macro that takes no arguments. What he doesn't know is that an empty identifier list is perfectly legal in C:  #define FILELOC() LOC  Even worse, the value of LOC will change permanently. This means that if you want the old value of LOC to simulate the pushing and popping of activation records, you need to save it manually. In other words, this won't work right:   #include &ltstdio.h> &nbsp void foo(void); &nbsp int main(void) {   TRACE(main); &nbsp   printf("%s\n", FILELOC());   foo();   printf("%s\n", FILELOC()); &nbsp   RETURN(0); } &nbsp void foo(void) {   TRACE(foo); &nbsp   printf("%s\n", FILELOC()); &nbsp   RETURN; } &nbsp   ... All in all, I find these macros (once fixed) ugly, awkward, and inelegant. If I were to do something like this, which I do sometimes, I would do it like so:   #include &ltstdio.h> &nbsp #define trace(log, msg) fprintf(log, "%s\n", msg) &nbsp void foo(void) {   trace(stderr, "Entry point: foo"); &nbsp   printf("Do stuff in foo\n"); &nbsp   trace(stderr, "Exit point: foo");   return; } &nbsp int main(void) {   trace(stderr, "Entry point: main"); &nbsp   printf("Do stuff in main\n");   foo(); &nbsp   trace(stderr, "Exit point: main");   return 0; } &nbsp   ... Not only is this simpler, it's also more flexible. The log can be any log file, stdout, or simply stderr as the example shows. In addition, a stack can be used to save the execution in memory instead of just printing it to file for later use. This way run-time verification can be done. I'll note that the author does mention this possiblity shortly after describing the ugly macros with his next brilliant set of ugly and error prone macros:  #define TRACE(a) push_on_stack(#a); #define RETURN {pop_stack(); return;} #define RETURN1(a) {pop_stack(); return(a);} #define FILELOC(n) show_stack(n)  Granted, this is better. But not much. I mean, really, if you're going to write a book you can at least make sure that your example code is both valid and robust. For toy programs meant to explain an algorithm or some such I can understand forgoing robustness, but when you're explaining a debugging technique, there's no excuse. Why? Because the robust code omitted from toy programs is almost always the debugging code. :-)  ROBIN'S A COWARD  I started using my Prelude account again on www.cprogramming.com, but I didn't spill the beans about Prelude not really existing except in my head. I have made a vow to be honest from now on, but because I'm scared of the repercussions of the whole truth, I'll probably not tell unless someone asks a pointed question. Unfortunately, that'll most likely happen with one of the people on those message boards that I consider a friend and have private conversations with regularly. :-(  It must be karma. If you lie too much, you end up being forced to tell the truth to the people that you respect the most and suffer their disappointment. Well, hopefully it'll end up okay and I can keep visiting cboard regularly. It would really be a pity to ditch that account out of embarrassment, I have well over 5500 posts made over like three years. That's a lot of time and effort to just throw away. I think the reaction I fear most is from Salem. He's a little too separated from the rest of the regulars to make friends, I think, but I still value his opinion of me.  DREAMING OF C  I finally started going back to Undernet's #c IRC channel. I remember C_Dreamer, but I never got to know him or spoke with him much. I know that hairyian is Ian Woods from Usenet, and I know that twkm is "Those who know me have no need of my name" from Usenet even though I don't know his name. ;-) kryp2nite (Salem from cboard) is another that I know, but even though he's around #c a lot he doesn't chat much.  Well, C_Dreamer made a passing reference to the CLINT library that he was writing and I remembered that CLINT was a library (without a name ;-)) that was being written by Richard Heathfield of comp.lang.c and "C Unleashed" fame. So a quick google search (I love google) for C_Dreamer mixed with Richard Heathfield turned up exactly what I expected: C_Dreamer was Richard Heathfield.  Now, I don't worship people, so I won't be treating him any differently now that I know who he is. At least now I have a good idea of what he's capable of and what he's done that I know of, so I won't make a fool out of myself. That's always a good thing. I know that I'll chat with him more often though. Not because I think he's a good programmer, but because he turned out to be both fun and witty, which makes for good chatting. :-)  A GOOD DAY  At work on Tuesday I made a point to be extra nice and (horrors!) bubbly around customers. I'm not sure if it was my attitude being contagious that did it, but nobody I talked to seemed to be in a bad mood. The day went very well. It was the first time in a long time that I was happy all day and went home in a good mood. It may have been a fluke though. I've tried being bubbly before and it broke down after only a few hours.  I can only hope that it works again every day until my vacation time. :-)
     
    
</post>

<date>17,May,2004</date>
<post>

	 
      I was browsing the nearest bookstores (yes, plural!) for anything interesting concerning programming and I think I may have stumbled across a gem. Usually the books are either "Let's write a program!" beginner stuff that I was embarrassed to read even when I actually was a beginner, or intermediate topics such as reference manuals, algorithms and data structures (the useful ones that don't fall into the first category), or books claiming to be advanced that really aren't. I've gotten used to trolling for the odd tidbit of good stuff in otherwise average books. Still, there are a few that stand out and shine, like Knuth's "The Art of Computer Programming" series, Bentley's "Programming Pearls", K&R, Stroustrup, "Programming Perl", etc...  I've noticed my interests taking different turns as I learned more and more about programming. First, I was concerned with purely syntactic issues and stuck with language primers and reference manuals. Then I moved on to more interesting semantic issues with algorithms and data structures, then I found software design in general interesting. Now I'm working on solidifying my advanced knowledge of fundamentals, which is what drew me to "Memory as a Programming Concept in C and C++" by Frantisek Franek. The topic is frighteningly fascinating, and hits home for me especially. For those who know C and read my last post, you'll notice that I put a lot of effort into defensive programming. Most of that effort is spent on memory related issues.  From the first few chapters, it looks to be a great book. I do have one bone to pick with the author though. He actually used void as the return type for main in a C program. That's a huge no-no unless the restrictions of the ANSI/ISO standard are removed by running on a freestanding (ie. embedded) implementation. Because the program in question used a standard library function that wasn't guaranteed to be available on a freestanding implementation, I have no choice but to assume that he was assuming a hosted implementation (especially considering the topic of the operating system loading binaries in a process). So he doesn't know standard C as well as I would hope. He also assumed shortly after that vanilla char is unsigned. I'm hopeful that the book doesn't make such blatant assumptions elsewhere, because that would seriously effect its usefulness to me. Fortunately, I can look past minor things like that as long as I'm alert. But I'd rather read a book like Knuth where I can be reasonably sure that everything is precise and accurate.  Sadly, the book is short, less than 300 pages. I'll probably fly through it a few times before the week is done. Assuming it's as good as I'm hoping that is. :-)  ROBIN'S A LIAR  I don't think of myself as a liar as much as a roleplayer. Let me explain. I see the internet as one big game. The big game has little games and you play different roles in each game. Some games consist solely of your persona and another game, like XWing: Alliance on the MSN Gaming Zone. I like to change personas a lot just for variety and to satisfy some perverse interest in communal psychological relationships. To make a long explanation shorter, I make up people, personalities, histories and such to see how others react to me while playing the game. Yes, I do pretend to be a guy quite a bit...  Now, most of the time this is fun and I enjoy it very much. But there's one persona that I just can't seem to get away from. I can't kill it because I've developed a lot of respect while wearing it, I can't come out with the truth for the same reason, and I've really gone overboard with the story telling. Worse yet, it's on a programming message board where the moderators are anal about checking IP addresses and such. So I've probably been noticed trying to use different accounts to test out different personas.  This message board is a place that I go to on a sub-daily basis, and I'd really like to just be myself because it's hard being the persona that I've cultivated, and her programming style is different enough from mine that I can't always catch inconsistencies. Of course, everyone there respects her for being a professional programmer with plenty of experience (which is a far cry from the real me) and for being blatantly honest. Naturally, I don't think the reactions would be good if they found out that I was lying through my teeth most of the time. But my programming knowledge matches hers because I was trying my best when answering questions.  I've been working on a new persona, but that isn't working out well. Now I'm seriously considering dumping that one and either telling the truth with the one I've used the most or making a new account that's the real me and dumping Prelude (that's her handle). Like most of my personas that get dumped, she'll just vanish and never come back, which is a pity because I put a lot of effort into her and everything she did for two years. The only other persona that's lasted as long is my oldest XWing: Alliance persona.  Telling the truth would hurt. A lot. I can only imagine the reactions, and of course they would never believe another thing I said even if I told the absolute truth. Worse, I respect quite a few people there and I really don't want them looking down on me. I'd probably be ridiculed every time I showed up and have to leave completely because they could always find out who I was no matter what account I used.  I really hope this book is good...
     
    
</post>

<date>16,May,2004</date>
<post>

	 
      WEEKENDS BITE!  I must be the only person the planet Earth that hates weekends. I have good reasons though, let me walk you through a typical weekend for me. I wake up (generally) around 9:00am, or later if I was tired. I always stay up late on Friday night watching the standup comedians on Comedy Central and I almost never miss watching CSI. I'll get up and cross the eleven inches between my bed and my computer to dive, program, walk newsgroups, etc... I do that for about three hours, at which time I have to get ready for work at 1:00pm. Everything is still okay, though at this point I'm dreading work.  I'll leave what happens at work up to the imagination, but let's just say that it consists of smiling and being bubbly while trying not to smack dumb people silly. And that's the good customers. It gets very stressful when they feel that they've been slighted and try to get free stuff by being the classic "irate customer". For the most part they get angry about things that happen before I even come to work that I don't know about and had nothing to do with. Naturally, my ignorance about their situation only succeeds in fueling their rage even more. But if I'm lucky I'll be asked to do data entry for the customer database.  I hate data entry. It's boring and tedious where I like mentally stimulating and enjoyable. Of course, I'm the "computer expert" among the employees, so naturally my boss thinks I enjoy getting carpal tunnel by entering names of people I hate (about 50 or 60 each records for each sitting) into a database. But, I hate customer service more than data entry, so I'll jump at the chance to get an hour or two of uninterrupted thought and relaxation while at work.  By about the third hour I'm half-seriously considering suicide. Well, not seriously at all, but it begins to look more attractive. All in all, I have to work ten hours on Saturday. I show up reluctantly at 1:00pm and lock everything up at 11:00pm. Even better, for the last four hours I'm usually all alone. Not only does that mean I have no one to palm off annoying customers on, it also increases the fear factor of getting robbed, violated and killed. Fortunately I get a reprieve at 11:00pm. I get to go home, take a shower, and what could only be considered a nap.  On Sunday, I have to get up at 4:30am so that I can be at work at 5:30am to open everything up and be ready for business (aka. my own personal hell) at 6:00am. So, assuming I go to bed about midnight (which is typical) and fall asleep the instant my head hits the pillow, I get a grand total of four and a half hours of sleep.  Now, I have no problem waking up. I can jump out of bed and be wide awake without any help at all, I don't even drink coffee. But lack of sleep makes me irritable. So unless very few customers come in between the time I open and about noon, I end up in a VERY bad mood on Sunday. Repeat Saturday's list of things that happen for another ten hours and I leave work at 4:00pm, but it's ten or fifteen after most of the time because the relief shift is usually late. That's my weekend.  Granted, I do have the rest of the day after I get off to do stuff, but I'm usually in too bad of a mood to go out with friends or be anything but a couch potato, one of those people you see at the gym that you don't want to approach because they look ticked off, or a jerk online. Xwing: Alliance is an outlet for my stress, so I'm well known for being an ass. It doesn't help that I win all of the games I play either, because a skilled player is untouchable. You can be a jerk and when they start whining, just say that they're bitter because you schooled them. :-) I'm really a nice person though. I'm just a victim of the surrounding environment most of the time...  SKIP LIST  I was coding idly on Friday when I discovered that I was writing the data types for a skip list. Apparently my subconscience was more interested in writing that library than I was. Who am I to argue with myself? So I actually put some effort into it and came up with something pretty good. Okay, it's nothing earth shattering, just a basic type independent library that implements the basic operations (insert/remove/search) in C. I didn't even come up with my own algorithms, I just stole them from William Pugh's original report on skip lists. Here's the demo that I used to test everything out before libizing everything. Note that the blogger will probably butcher my formatting or make it impossible to cut and paste properly.   /*   Copyright (C) 2004 Robin Cole &nbsp   - Created (5/14/2004) Robin Cole   - Final touches (5/15/2004) Robin Cole &nbsp   xlist - Skip list demo implementation &nbsp   Dependencies: Expects xitem and xitem.h to exist */ #include &ltassert.h> #include &ltstdio.h> #include &ltstdlib.h> #include "public.h" #include "xitem.h" &nbsp typedef struct node xnode; typedef struct list xlist; &nbsp struct node {   xitem  *item;   /* Client contents */   int     height; /* # of next links */   xnode **next;   /* Skip links, dynamically allocated */ }; &nbsp /* xnode accessors */ #define xnode_item(x) (deref(x)->item) #define xnode_height(x) (deref(x)->height) #define xnode_next(x) (deref(x)->next) #define xnode_next_i(x, i) (deref(x)->next[bounds(i, xnode_height(x))]) &nbsp xnode *make_xnode(xitem *item, int height, xnode *nil); void   destroy_xnode(xnode *node, void (*destroy)(xitem *old_xitem)); &nbsp struct list {   xnode  *head;                         /* Dummy header of skip list */   xnode  *nil;                          /* Private sentinel node */   int     size;                         /* Number of client items */   int     max_height;                   /* Maximum possible skip height (client defined) */   int   (*compare)(xitem *a, xitem *b); /* Generic comparison for items */ }; &nbsp /* xlist accessors */ #define xlist_head(x) (deref(x)->head) #define xlist_nil(x) (deref(x)->nil) #define xlist_size(x) (deref(x)->size) #define xlist_height(x) (xnode_height(xlist_head(x))) #define xlist_max_height(x) (deref(x)->max_height) #define xlist_compare(x) (deref(x)->compare) &nbsp xlist *make_xlist(int max_height, int (*compare)(xitem *a, xitem *b)); void   destroy_xlist(xlist *list, void (*destroy)(xitem *old_xitem)); int    insert_xlist(xlist *list, xitem *item); int    remove_xlist(xlist *list, xitem **old_item, xitem *item); int    search_xlist(xlist *list, xitem **found_item, xitem *item); void   display_xlist(xlist *list); &nbsp int main(void) {   xlist *list;   xitem *item, *save;   int    i;   char  *a[] = {     "a","h","b","g","c","f","d","e","d","a","h" /* Alternating insertion and duplicates */     /* "a","b","c","d","e","f","g","h","d","a","h" /* Ascending insertion and duplicates */     /* "h","g","f","e","d","c","b","a","d","a","h" /* Descending insertion and duplicates */   }; &nbsp   list = make_xlist(4, compare_xitem);   if (!list) {     fprintf(stderr, "Fatal error: Data structure creation failed\n");     return EXIT_FAILURE;   }   for (i = 0; i      xitem *new_item = make_xitem(a[i]);     if (!new_item) {       fprintf(stderr, "Error creating item\n");       break;     }     if (!insert_xlist(list, new_item)) {       fprintf(stderr, "Error inserting item\n");       destroy_xitem(new_item);     }     display_xlist(list);     printf("\n===============\n");     getchar();   }   item = make_xitem("e");   if (item) {     printf("Search result: %d\n", search_xlist(list, &save, item));     remove_xlist(list, &save, item);     if (save) {       destroy_xitem(save);     }     display_xlist(list);     printf("\n===============\n");     getchar();     printf("Search result: %d\n", search_xlist(list, &save, item));     destroy_xitem(item);   }   destroy_xlist(list, destroy_xitem); &nbsp   return EXIT_SUCCESS; } &nbsp /*   xnode handlers */ &nbsp /* Allocate and initialize an xnode */ xnode * make_xnode(   xitem *item,   /* May be null to represent invalid items */   int    height,   xnode *nil   ) {   xnode *node; &nbsp   assert(nil != NULL);   assert(height > 0);   assert(nil != NULL); /* Wierd */   node = xmalloc(node);   call_trace("xmalloc: node in make_xnode");   if (!node) {     fprintf(stderr, "Memory exhausted\n");     return NULL;   }   xnode_next(node) = xnmalloc(xnode_next(node), height);   call_trace("xnmalloc: xnode_next(node) in make_xnode");   if (!xnode_next(node)) {     fprintf(stderr, "Memory exhausted\n");     xfree(node);     call_trace("xfree: node in make_xnode");     return NULL;   }   xnode_item(node) = item;   xnode_height(node) = height;   while (height--) {     xnode_next_i(node, height) = nil;   } &nbsp   return node; } &nbsp /* Release memory for an xnode */ void destroy_xnode(   xnode  *node,   void  (*destroy)(xitem *old_xitem) /* Function for destroying an item, may be null */   ) {   assert(node != NULL);   xfree(xnode_next(node));   call_trace("xfree: xnode_next(node) in destroy_xnode");   if (xnode_item(node) && destroy) {     destroy(xnode_item(node));   }   xfree(node);   call_trace("xfree: node in destroy_xnode"); } &nbsp /*   xlist handlers */ &nbsp /* Allocate and initialize an xlist */ xlist * make_xlist(   int   max_height,                   /* Largest possible height of a node */   int (*compare)(xitem *a, xitem *b)  /* Function for comparing items */   ) {   xlist *list; &nbsp   assert(max_height > 0);   assert(compare != NULL);   list = xmalloc(list);   call_trace("xmalloc: list in make_xlist");   if (!list) {     fprintf(stderr, "Memory exhausted\n");     return NULL;   }   xlist_nil(list) = xmalloc(xlist_nil(list));   call_trace("xmalloc: xlist_nil(list) in make_xlist");   if (!xlist_nil(list)) {     fprintf(stderr, "Memory exhausted\n");     xfree(list);     call_trace("xfree: list in make_xlist");     return NULL;   }   xnode_item(xlist_nil(list)) = NULL;   xlist_head(list) = make_xnode(NULL, max_height, xlist_nil(list));   if (!xlist_head(list)) {     fprintf(stderr, "Internal error: make_xnode\n");     xfree(xlist_nil(list));     call_trace("xfree: xlist_nil(list) in make_xlist");     xfree(list);     call_trace("xfree: list in make_xlist");     return NULL;   }   xlist_size(list) = 0;   xlist_height(list) = 1;   xlist_max_height(list) = max_height;   xlist_compare(list) = compare; &nbsp   return list; } &nbsp /* Release memory for an xlist */ void destroy_xlist(   xlist  *list,   void  (*destroy)(xitem *old_xitem) /* Function for destroying an item, may be null */   ) {   xnode *node; /* Traverse the list */   xnode *save; /* Save the link for memory release */ &nbsp   assert(list != NULL);   node = xlist_head(list);   while (node != xlist_nil(list)) {     save = xnode_next_i(node, 0);     destroy_xnode(node, destroy);     node = save;   }   xfree(xlist_nil(list));   call_trace("xfree: xlist_nil(list) in destroy_xlist");   xfree(list);   call_trace("xfree: list in destroy_xlist"); } &nbsp /* Random height [0..max_height) with probability 1/2 */ static int random_height(   int max_height /* Exclusive upper bound */   ) {   int height = 1; &nbsp   while ((double)rand() / RAND_MAX      ++height;   } &nbsp   return height; } &nbsp /* Insert an item into an xlist */ int insert_xlist(   xlist *list,   xitem *item  /* Item to insert */   ) {   xnode **update; /* Saved links for list restructuring */   xnode  *node;   /* Traverse the list */   int     n;      /* Bounds limit for update */   int     i; &nbsp   assert(list != NULL);   assert(item != NULL);   n = xlist_max_height(list);   update = xnmalloc(update, n);   call_trace("xnmalloc: update in insert_xlist");   if (!update) {     fprintf(stderr, "Memory exhausted\n");     return 0;   }   node = xlist_head(list);   for (i = xlist_height(list) - 1; i >= 0; i--) {     xitem *current_item = xnode_item(xnode_next_i(node, i));     while (current_item && (*xlist_compare(list))(current_item, item)        node = xnode_next_i(node, i);       current_item = xnode_item(xnode_next_i(node, i));     }     update[bounds(i, n)] = node;   }   node = xnode_next_i(node, 0);   if (xnode_item(node) && (*xlist_compare(list))(xnode_item(node), item) == 0) {     fprintf(stderr, "Warning: Duplicate detected. List is unchanged\n");     xfree(update);     call_trace("xfree: update in insert_xlist");     return 0;   }   else {     int height = random_height(xlist_max_height(list));     if (height > xlist_height(list)) {       for (i = xlist_height(list); i          update[bounds(i, n)] = xlist_head(list);       }       xlist_height(list) = height;     }     node = make_xnode(item, height, xlist_nil(list));     if (!node) {       fprintf(stderr, "Internal error: make_xnode\n");       xfree(update);       call_trace("xfree: update in insert_xlist");       return 0;     }     for (i = 0; i        xnode_next_i(node, i) = xnode_next_i(update[bounds(i, n)], i);       xnode_next_i(update[bounds(i, n)], i) = node;     }     ++xlist_size(list);   }   xfree(update);   call_trace("xfree: update in insert_xlist"); &nbsp   return 1; } &nbsp /* Remove an item from an xlist */ int remove_xlist(   xlist  *list,   xitem **old_item,  /* Save the old item for client use */   xitem  *item       /* item to search for */   ) {   xnode **update; /* Saved links for list restructuring */   xnode  *node;   /* Traverse the list */   int     n;      /* Bounds limit for update */   int     i; &nbsp   assert(list != NULL);   assert(old_item != NULL);   assert(item != NULL);   n = xlist_max_height(list);   update = xnmalloc(update, n);   call_trace("xnmalloc: update in insert_xlist");   if (!update) {     fprintf(stderr, "Memory exhausted\n");     return 0;   }   node = xlist_head(list);   for (i = xlist_height(list) - 1; i >= 0; i--) {     xitem *current_item = xnode_item(xnode_next_i(node, i));     while (current_item && (*xlist_compare(list))(current_item, item)        node = xnode_next_i(node, i);       current_item = xnode_item(xnode_next_i(node, i));     }     update[bounds(i, n)] = node;   }   node = xnode_next_i(node, 0);   if (xnode_item(node) && (*xlist_compare(list))(xnode_item(node), item) == 0) {     xnode *next; /* Link for shrink step */     for (i = 0; i        if (xnode_next_i(update[bounds(i, n)], i) != node) {         break;       }       xnode_next_i(update[bounds(i, n)], i) = xnode_next_i(node, i);     }     *old_item = xnode_item(node);     xfree(xnode_next(node));     call_trace("xfree: xnode_next(node) in remove_xlist");     xfree(node);     call_trace("xfree: node in remove_xlist");     next = xnode_next_i(xlist_head(list), xlist_height(list) - 1);     while (xlist_height(list) > 0 && next == xlist_nil(list)) {       --xlist_height(list);       next = xnode_next_i(xlist_head(list), xlist_height(list) - 1);     }     --xlist_size(list);     xfree(update);     call_trace("xfree: update in remove_xlist");     return 1;   }   else {     *old_item = NULL;     xfree(update);     call_trace("xfree: update in remove_xlist");     return 0;   } } &nbsp /* Locate an item in an xlist */ int search_xlist(   xlist  *list,   xitem **found_item,  /* Save the found item for client use */   xitem  *item         /* item to search for */   ) {   xnode *node; /* Traverse the list */   int    i; &nbsp   assert(list != NULL);   assert(found_item != NULL);   assert(item != NULL);   node = xlist_head(list);   for (i = xlist_height(list) - 1; i >= 0; i--) {     xitem *current_item = xnode_item(xnode_next_i(node, i));     while (current_item && (*xlist_compare(list))(current_item, item)        node = xnode_next_i(node, i);       current_item = xnode_item(xnode_next_i(node, i));     }   }   node = xnode_next_i(node, 0);   if (xnode_item(node) && (*xlist_compare(list))(xnode_item(node), item) == 0) {     *found_item = xnode_item(node);     return 1;   }   else {     *found_item = NULL;     return 0;   } } &nbsp /* Safe print from display_xlist */ static char * get_item(   xitem *item   ) {   if (!item) {     return "(null)";   }   else {     return xitem_item(item);   } } &nbsp /* Display details and structure of an xlist */ void display_xlist(   xlist *list   ) {   xnode *node;   int    i; &nbsp   assert(list != NULL);   printf("List size:  %d\n"          "nil:        %p\n"          "Max height: %d\n\n", xlist_size(list), (void *)xlist_nil(list), xlist_max_height(list));   node = xlist_head(list);   while (node != xlist_nil(list)) {     printf("Address:      %p\n"            "Item:    %s\n"            "Height:  %d\n"            "Next:    ", (void *)node, get_item(xnode_item(node)), xnode_height(node));     for (i = 0; i        printf("[%d]: %p ", i, (void *)xnode_next_i(node, i));     }     printf("\n\n");     node = xnode_next_i(node, 0);   } } &nbsp   Here's the rest of the stuff for anyone that cares (probably nobody).   /*   Copyright (C) 2004 Robin Cole &nbsp   xitem.h - Application specific data structure contents.     Make changes to this file and xitem.c to specialize. */ #ifndef XITEM #define XITEM &nbsp /* Required typedef for compatibility */ typedef struct object xitem; &nbsp struct object {   char *item; }; &nbsp #define xitem_item(x) (deref(x)->item) &nbsp int compare_xitem(xitem *a, xitem *b); xitem *make_xitem(char *item); void destroy_xitem(xitem *old_xitem); &nbsp #endif &nbsp    xitem.c doesn't do anything spectacular.    /*   Copyright (C) 2004 Robin Cole &nbsp   xitem.c - Application specific definitions for xitem. */ #include &ltassert.h> #include &ltstring.h> #include "public.h" #include "xitem.h" &nbsp /*   Compare two xitems. Return -1, 0, +1 if a is less, equal or greater */ int compare_xitem(xitem *a, xitem *b) {   assert(a != NULL);   assert(b != NULL);   return strcmp(xitem_item(a), xitem_item(b)); } &nbsp /*   Create a new xitem. Return a pointer to the memory block. */ xitem *make_xitem(char *item) {   xitem *new_xitem; &nbsp   assert(item != NULL);   new_xitem = xmalloc(new_xitem);   call_trace("xmalloc: new_xitem in make_xitem");   if (!new_xitem) {     fprintf(stderr, "%s : %d -- Memory exhausted\n", __FILE__, __LINE__);     return NULL;   }   xitem_item(new_xitem) = xnmalloc(xitem_item(new_xitem), strlen(item) + 1);   call_trace("xnmalloc: xitem_item(new_xitem) in make_xitem");   if (!xitem_item(new_xitem)) {     fprintf(stderr, "%s : %d -- Memory exhausted\n", __FILE__, __LINE__);     xfree(new_xitem);     call_trace("xfree: new_xitem in make_xitem");     return NULL;   }   strcpy(xitem_item(new_xitem), item); &nbsp   return new_xitem; } &nbsp /*   Destroy an existing xitem and its contents */ void destroy_xitem(xitem *old_xitem) {   xfree(xitem_item(old_xitem));   call_trace("xfree: xitem_item(old_xitem) in destroy_xitem");   xfree(old_xitem);   call_trace("xfree: old_xitem in destroy_xitem"); } &nbsp   Here's public.h.   /*   public.h - Public declarations and macros */ #ifndef PUBLIC #define PUBLIC &nbsp #include &ltassert.h> #include &ltstdio.h> #include &ltstdlib.h> &nbsp #define VERBOSE #if defined (VERBOSE) #  define trace(msg, file, line, var) printf(msg, file, line, var) #  define call_trace(msg) printf("%s\n", msg) #else #  define trace(msg, file, line, var) printf("") #  define call_trace(msg) #endif &nbsp extern unsigned long alloc_count; #define xmalloc(x) (++alloc_count,   trace("%s - alloc line %d: balance -- %ld\n", __FILE__, __LINE__, alloc_count), malloc(sizeof *(x))) #define xnmalloc(x, n) (++alloc_count,   trace("%s - alloc line %d: balance -- %ld\n", __FILE__, __LINE__, alloc_count), malloc((n) * sizeof *(x))) #define xfree(x) (alloc_count = x ? alloc_count - 1 : alloc_count,   trace("%s - free line %d: balance -- %ld\n", __FILE__, __LINE__, alloc_count), free(x)) &nbsp #define deref(x) (assert((x) != NULL), (x)) #define bounds(i, n) (assert((i) >= 0 && (i)  &nbsp #endif &nbsp  
     
    
</post>

<date>14,May,2004</date>
<post>

	 
      I woke up early again today. 6:40 is really early for me, even on days that I have to work. I don't know why, maybe it's just getting lighter earlier and that keeps waking me up. But it's never been a problem before.  Because I was wide awake, I decided to get up and do some net diving. The usual activities ensue. I checked out www.megatokyo.com and found it updated (Woohoo!), then went through my newsgroups and message boards to answer programming questions. When I ran out of questions, I had half of an inkling to write a skip list library to pass the time.  Skip lists are really simple. I can usually get them right on the first try, so writing a generic library for future use would be a good idea. I'm just not sure if I would use it because, like most programmers, I prefer absolute guarantees rather than probabilistic "expected" performance, "but only if the random numbers are good". Okay, so skip lists aren't perfect, but they are better than basic linked lists and much easier to work with than balanced trees.  Of course, I'm still lazy, and an inkling doesn't have enough pull to get me to write something more complex than a little example program to answer a question. At least by answering questions I can show off what I know and can do without looking like an egomaniac. I like it when people praise me, but it's hard to get that fix without also having people look down on me for arrogance. I do have a big ego, but I don't flaunt it. Really! Well, except when I'm schooling people in Xwing: Alliance. :-)  I'm kind of depressed because I don't have anything to do or occupy my mind with. Hell, I don't even have an interesting fantasy to keep my imagination from jumping around a lot. Fantasies have been my way of fighting boredom for as long as I can remember. When I run out of good ideas for all of my fantasies, I get depressed because the boredom really starts to set in. Time goes slower too. Even more so because I'm usually at work when this happens. What really sucks is that it's been happening most of the time, so I end up feeling depressed about my life because I can't hide in my imagination.  I loathe having nothing to occupy my mind. If I'm not thinking about something interesting, it irritates me greatly and I get a little bitchy. Writing a good library would probably give me something to work mull over, but not a skip list. I've done that before and solved the problems that are interesting. But I can't think of any good library that would interest me right now.   I have to go to work today. That should be "fun". I've been working at the same place for over eight years now. That's a long time. Long enough to be really good at everything I do, but also long enough to become jaded and bitter. I work directly with customers, which is ironic because I don't work well with other people (that's probably why people rarely take an interest in me romantically, it's not like I'm not a good catch or anything). Well, I can go in to work in a fantastic mood and leave work totally pissed off. That's how much the customers chafe against my personality. It's likely because I know how this stuff works and I can use it properly that I see customers as idiots. I mean, how hard is it to locate and press a flashing button that's right in front of your face?  All I ask is that the next two weeks pass quickly so that I can go on a week vacation. At least that way I can justify having nothing to think about. That's what vacations are for, right? Clearing your mind of distractions and relaxing on a beach while working on your tan. I may not even take my laptop...
     
    
</post>

<date>13,May,2004</date>
<post>

	 
      I originally planned to use blogs as an outlet for my angst riddled thoughts. So naturally, when I set up my blog I found that I was in a good mood and had a pretty good day. Of course, I still have to go to work tomorrow and all weekend after that. Joy.  I woke up surprisingly early today for no obvious reasons. I remember that the power went out for a few seconds and woke me up about 3am, but I woke up again at about 6:30am and was so wide awake that I slinked out of bed and played around on my computer. I was planning on fiddling around with a problem that was clearly easy, yet I couldn't manage to get it to work perfectly.  THE TREE  The night before I had been working on the DSW algorithm for balancing a binary search tree. The first attempt was composed of my own understanding of the algorithm which turned out to be correct, but still wouldn't work. The second attempt was blatant plagiarism from the original ACM article depicting the algorithm in Pascal (I was working with C though). Strangely enough, the "official" algorithm gave me the same problems. It would work alright for a degenerate tree until about the 24th item and then die with a segmentation violation. That was strange enough because my code oozes defenses against such things.  The third incarnation was a character for character copy of Ben Pfaff's (He's my binary search tree hero) libavl balancing method. It uses the same basic algorithm as I had been working on. I was hoping that his unique idea for calculating the number of leaves before reconstructing a balanced tree from the vine would give me insight. Unfortunately I had the same problems as the other two attempts. Because my code is always perfect, I knew it couldn't possibly be anything else... Okay, that's a lie. My code is only perfect on the third or fourth try with something nontrivial. But this particular binary search tree was trivial, and I've written it a hundred times before and I tested it thoroughly. So I'm sure enough that it's correct.  Well, I ended up getting pissed and throwing away everything I had in favor of a crappier approach that I knew for a fact I could get right on the first try. I wrote a balancing routine that copied the tree in order to a dynamic array and then rebalanced the tree by removing all of the items and reinserting them from a binary search on the array. Not the best solution, but it's still technically O(n) performance-wise.  I finally got it working on the third try. I think because I was pissed off to begin with I missed a few subtle yet important details, like trying to reassign the pointer passed to the rebalance function and expecting the changes to persist back to the calling function. I ended up rewriting it once before noticing that (by that time I had cooled off I believe). So the rebalance routine now works, and I set up the tree to rebalance itself when the depth of the path taken to insert a new item exceeds log(tree->size). Lazy, yes. But it works without letting the tree get to far out of balance or performing the expensive rebalance "too" often.  HAIR GEL  Okay, here's how it's been for all of my life that I can remember. I've always avoided putting any chemicals in my hair besides shampoo and conditioner because I'm wierd. But today I finally cracked. My hair has been short for a few years now, and I want to grow it out again. But there's this irritating intermediate stage where the hair is long enough to be unmanageable and short enough so that you can't get it out of the way by tying it back. Granted, I was in a bad mood to begin with, but my patience was wearing thin and I was afraid I might "actually" go out and do something insane like shave my head. That's really only going to be an option if I have radiation therapy or something. So I bought some hair gel when I was out getting some more shampoo and conditioner.  When I got home and tried it out, I was shocked. Ironically, hair gel really does work! It's not greasy or yucky either. My expectations were way off, and I think I'll probably continue to use it for the more frustrating parts of my hair until it's long enough to do the whole ponytail thing again. I'm still in the trial period though. I've used it when my hair was dry and that works okay, but is still a little wavy (I have really wavy hair when it gets longer). Supposedly this stuff works when your hair is wet too, I'm going to try that out the next time I take my shower. Here's hoping that it works.  AIR CONDITIONING  My office space is HOT! Now, when I say HOT, I mean body parts sticking to other parts that they shouldn't be sticking to, sweat drenched and miserable. The kind of HOT that a cold drink will never help and you just want to drown in a bathing tub full of ice water. And this is when the air conditioning is working. The vents are clogged or something and I barely get any airflow at all. So you can imagine that when some valve on the compressor melted and started leaking freon, the temperature of my work area skyrocketed.  It got to be so bad that I spent less time working on my computer and more time doing other, less productive things. I think that's what started my angsty depression stage that I'm not sure I'm out of yet. Without my computer I couldn't program, I couldn't net dive, I couldn't answer programming questions on newsgroups or message boards, I couldn't play games, I couldn't even write! My book lies dormant, stagnant, begging to be added to so that the final two chapters might be completed and it can live a life of prosperous manhandling by readers of all ages. I say this as if I weren't in a near constant state of writer's block...  But praise to the geeks! While perusing www.thinkgeek.com I noticed something in the new items. A desktop air conditioner! Cool! With my trusty credit card in hand, I ordered the desktop air conditioner with the hope that it could end my suffering. Next day air delivery because HOT. And I'm impatient, but mostly the HOT.  Now, the usual end to these types of stories for me is that the device is buggered and I'm out whatever amount of cash it cost me. But this thing does help, and it's battery powered. And it has a DC connector if I run out of batteries! It works like this: the thing is basically a nifty looking light grey fan. You take a plastic bottle that fits between the fan and the vent, fill it with ice water or just plain water and let it freeze in the freezer, then put it back in the unit and turn on the fan. The idea is that the cold radiating off of the frozen and condensing plastic bottle will cool the air that the fan pushes out the vent and onto a most relieved face.  It works! It really does...but not great. The fan is a little too weak to get the air going out as much as I would like, so I have to set it pretty close to me. I didn't expect it to cool me to the bone or anything, but my legs still sweat and my back still sweats because the airflow doesn't really penetrate my leather chair very well. So, coupled with a few ice packs, the thing works well enough that I can continue my life of geekdom.  THE JOB  Speaking of geekdom, I'm lazy. Really lazy. Detrimentally lazy. In high school I took the vocational route so that I wouldn't have to take a foreign language. This is much to my chagrin now as linguistics is one of my side hobbies. Since I didn't have a foreign language, college would have been a bitch, so I ended up doing an associates degree in computer programming. Two years, piece of cake because I'm smart, and I can get a job right away because the market is booming. What a deal!  Of course, and I say "of course" because this is typical of my luck, 9-11 happens just before I graduate with my crisp degree and the recession gets worse and the field totally DIES. No job for the Cute Coder, sorry. I sit and look (half-heartedly) for a job online for the next two years. Good thing I have a steady job right now or I'd long since have had many bad things happen. I don't get paid much, but it is enough to maintain my lazy lifestyle of surfing the web, watching TV, trying to eat right and stay in the good shape that I'm in, and of course, there's that "of course" again, working at a job that has a tendency of crushing any vestige of happiness I have after the first two hours of an eight hour shift.  If only I had taken Japanese or something cool in high school, I would be in college now. No, I would just be graduating college now if I were doing a four year bachelor's of computer science. I'd have a semi-bright future, or at least a lustrous appearance of a future that college graduates have. It may only turn out to be a the brilliant fake of a rhinestone, but at least it "looks" like something.  I worry about my future a lot now that I'm on a deadline for leaving the parent's place. Less than a year. I promised that I would probably be gone by 2005, so I have to find a job that will support me having real bills by then. Yet I'm still lazy...  It's not that I couldn't get a job as a software engineer. I have no professional experience, but I TEACH professionals with decades of experience how to program. I've corrected professors with PhD's in computer science on technical topics. I know more about C than most active programmers these days. And yet I find myself sitting at my mother's house, typing a blog because I'm lazy. I could be finishing my book. I could be interviewing for jobs. I could be getting a diet coke from the refrigerator...  There, wasn't that productive? Diet Coke with Lime. The lime flavor almost hides the nasty taste of the diet coke. But I can't drink real coke because the sugar would make me fat. I drink too much soda to risk that because I fear being fat.  Well, it seems like the angst is coming back. I can tell because I'm getting bored. Earlier I had plenty of questions to answer on some of the programming message boards I frequent and the whole program-is-working happiness mixed with hair gel euphoria. But now it's slowing down. It's Thursday too, no good web comics update on Thursday. Pity.  And there's probably nothing on TV either. And I have to work tomorrow...dammit.
     
    
</post>


</Blog>