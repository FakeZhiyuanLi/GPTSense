<Blog>

<date>26,June,2004</date>
<post>

	 
      We can get the message count of a message queue using MSMQ Local Admin API  MQMgmtGetInfo() . This API is fully supported by Microsoft on all versions of MSMQ. We can call this API from C#.NET directly as P/Invoke. Or we can write a C++ Managed wrapper over it and then call it from C#.NET. I preferred the second approch because it is much faster and there is no possibility of runtime data type mismatches as it is there in P/Invoke.  To call this API, we need two files; 1)  mq.h  and 2)  mqrt.lib . Both these files should be there in your system if you have VC++ 7.0 (i.e., VC++ of .NET 2003) installed on your system.  Now start a new VC++ Class Library project "MsmqApiLib" in your .NET IDE. Add mqrt.lib as an external dependency of that project. And then include the mq.h in your MsmqApiLib.cpp file.  And then embed the following code in your function body -  ========================================= // Machine -> Name of the remote machine //            or NULL for local machine. // eg, buddha // Queue   -> Formated name of the queue //            with " queue= " as prefix. // eg, queue=DIRECT=OS:buddha\private$\msmqtriggersnotifications // // From C#.NET you can use this function as - // // PalBiswas.MSMQ.MsmqApiLib mqLib = new PalBiswas.MSMQ.MsmqApiLib(); // long count = mqLib.GetMessageCount( "buddha", //    "queue=DIRECT=OS:buddha\private$\msmqtriggersnotifications" ); // ========================================= long MsmqApiLib::GetMessageCount( String *Machine, String *Queue ) {     const wchar_t __pin* m = PtrToStringChars( Machine );     const wchar_t __pin* q = PtrToStringChars( Queue );      QUEUEPROPID   propId[1];     MQPROPVARIANT propVar[1];     HRESULT       propStatus[1];     DWORD         cprop = 0;      propId [cprop] = PROPID_MGMT_QUEUE_MESSAGE_COUNT;     propVar[cprop].vt = VT_NULL;     ++cprop;      MQMGMTPROPS mqProps;      mqProps.cProp    = cprop;     mqProps.aPropID  = propId;     mqProps.aPropVar = propVar;     mqProps.aStatus  = propStatus;      HRESULT hr = MQMgmtGetInfo( m, q, &mqProps );      if( FAILED( hr ) )     {         return -1;     }     else     {         return mqProps.aPropVar[0].ulVal;     } } =========================================   NB: Using this API you will get the message count of only  ACTIVE (ie, open)  queues. 
    
</post>

<date>15,June,2004</date>
<post>

	 
       An Astronaut   By Cynthia Wallace  I once wished to float above the earth, so clear and blue But then I realized the trouble I'd go through to float above the Earth As any smart person would do, I reached for my goals with potential and strength and now here I am, floating in Outer Space!  Many of us dreamed of becoming an astronaut when we were young. Some of us never got over that dream. But  John Glenn  rode the shuttle in 1998 at the age of 77;  :-) So keep your dreem alive and try hard to make it.  So, how do you become an astronaut? Few tips - ;-)  1. Learn how to work effectively in a team environment.  2. The "minimum degree requirement" is a bachelor's from an accredited institution. A good "Master of Science" is better.  3. After college, 3 years of related increasingly responsible professional experience.  4. Very good communication skill, not only verbally, but written as well. It's a good idea for an astronaut to be bilingual as well.   5. And get ready for a rigorous training program.  Being an astronaut can be hard on family life .  6. Health # Height 64 and 76 inches, 20/70 Corrected to 20/20, blood Pressure-140/90.  [All these information are collected from different sites.]
    
</post>

<date>06,July,2004</date>
<post>

	 
      Answered by Anders Hejlsberg, The chief designer of C# (Also creator of Pascal compiler, lead architect of Delphi,VJ++ and the Windows Foundation Classes).  In Java, instance methods are virtual by default. They can be overridden in subclasses unless they are explicitly declared final. In C#, by contrast, instance methods are non-virtual by default. To make a method virtual, the programmer must explicitly declare it virtual.    There are several reasons. One is performance. We can observe that as people write code in Java, they forget to mark their methods final. Therefore, those methods are virtual. Because they're virtual, they don't perform as well. There's just performance overhead associated with being a virtual method. That's one issue.   A more important issue is versioning. There are two schools of thought about virtual methods. The academic school of thought says, "Everything should be virtual, because I might want to override it someday." The pragmatic school of thought, which comes from building real applications that run in the real world, says, "We've got to be real careful about what we make virtual." When we make something virtual in a platform, we're making an awful lot of promises about how it evolves in the future. For a non-virtual method, we promise that when you call this method, x and y will happen. When we publish a virtual method in an API, we not only promise that when you call this method, x and y will happen. We also promise that when you override this method, we will call it in this particular sequence with regard to these other ones and the state will be in this and that invariant. Every time you say virtual in an API, you are creating a call back hook. As an OS or API framework designer, you've got to be real careful about that. You don't want users overriding and hooking at any arbitrary point in an API, because you cannot necessarily make those promises. And people may not fully understand the promises they are making when they make something virtual.  I can demonstrate to you a very real world versioning problem, one that indeed we see now from experience with Java. Whenever they ship a new version of the Java class libraries, breakage occurs. Whenever they introduce a new method in a base class, if someone in a derived class had a method of that same name, that method is now an override except if it has a different return type, it no longer compiles. The problem is that Java, and also C++, does not capture the intent of the programmer with respect to virtual.  When you say "virtual," you can mean one of two things. If you did not inherit a method of the same signature, then this is a new virtual method. That's one meaning. Otherwise it is an override of an inherited method. That's the other meaning. From a versioning perspective, it is important that the programmer indicate their intent when they declare a method virtual. In C#, for example, you must explicitly indicate which meaning of virtual you intend. To declare a new virtual method, you just mark it virtual. But to override an existing virtual method, you must say override.   As a result, C# doesn't have the particular versioning problem I described earlier in which we introduce a method in a base class that you already have in a derived class. In your class, you would have declared foo virtual. Now we introduce a new virtual foo. Well, that's fine. Now there are two virtual foos. There are two VTBL slots. The derived foo hides the base foo, but that's fine. The base foo wasn't even there when the derived foo was written, so it's not like there's anything wrong with hiding this new functionality. And things continue to work the way they're supposed to. 
    
</post>

<date>05,July,2004</date>
<post>

	 
        Answered by  Anders Hejlsberg , The chief designer of C# (Also creator of Pascal compiler, lead architect of Delphi,VJ++ and the Windows Foundation Classes).    I see two big issues with checked exceptions: scalability and versionability. Frankly, checked exceptions look really great up front, and there's nothing wrong with the idea. I completely agree that checked exceptions are a wonderful feature. It's just that particular implementations can be problematic. By implementing checked exceptions the way it's done in Java, for example, I think you just take one set of problems and trade them for another set of problems. In the end it's not clear to me that you actually make life any easier. You just make it different.     Let's start with versioning, because the issues are pretty easy to see there. Let's say I create a method foo that declares it throws exceptions A, B, and C. In version two of foo, I want to add a bunch of features, and now foo might throw exception D. It is a breaking change for me to add D to the throws clause of that method, because existing caller of that method will almost certainly not handle that exception.     Adding a new exception to a throws clause in a new version breaks client code. It's like adding a method to an interface. After you publish an interface, it is for all practical purposes immutable, because any implementation of it might have the methods that you want to add in the next version. So you've got to create a new interface instead. Similarly with exceptions, you would either have to create a whole new method called foo2 that throws more exceptions, or you would have to catch exception D in the new foo, and transform the D into an A, B, or C.    The scalability issue is somewhat related to the versionability issue. In the small, checked exceptions are very enticing. With a little example, you can show that you've actually checked that you caught the FileNotFoundException, and isn't that great? Well, that's fine when you're just calling one API. The trouble begins when you start building big systems where you're talking to four or five different subsystems. Each subsystem throws four to ten exceptions. Now, each time you walk up the ladder of aggregation, you have this exponential hierarchy below you of exceptions you have to deal with. You end up having to declare 40 exceptions that you might throw. And once you aggregate that with another subsystem you've got 80 exceptions in your throws clause. It just balloons out of control.  
    
</post>


</Blog>