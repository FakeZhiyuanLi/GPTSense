<Blog>


<date>25,May,2004</date>
<post>

     
      
     
    
</post>

<date>25,May,2004</date>
<post>

     
       Well, this is my first time entering this site.  What a cool tool!  I wonder how does actually Google make money of this free site? Ok...ok, I know from Advertisements, isn'it?  Anyway, I love this site.  May be in near future I'll put more stuff here. For now, that's all I have on this page. 
     
    
</post>


<date>19,February,2004</date>
<post>

    
       
      This is my first attempt to put something to blogger.  Sorry, it has nothing in it for now.
       
    
    
</post>

<date>28,May,2004</date>
<post>

    
       
        urlLink Linux on the PS2  by John Littler -- As consoles increase in power and alternate operating systems increase in functionality and flexibility, it's ever more attractive to port your favorite free operating system. In the case of Sony's PlayStation 2, the company even encourages it. John Littler explores Linux on the PS2, including hardware, installation, upgrades, alternatives, and game programming. 
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink coLinux: Linux for Windows Without Rebooting  by KIVILCIM Hindistan -- Trying Linux just keeps getting easier. Knoppix and other live CDs let you take Linux with you on CD and USB keys, but you have to reboot to run your software. What about Windows users who want to use Linux in conjunction with their existing systems? KIVILCIM Hindistan explores the world of coLinux -- cooperative Linux. 
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Build Strings with { }  by Jerry Peek -- Save typing by expanding strings at the shell prompt. Learn hot to use the {} pattern-expansion characters in this excerpt from Unix Power Tools, 2nd Edition.   
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Using and Customizing Knoppix  by Robert Bernier -- Several Linux distributions boot directly from CD-ROMs. How many are usable in that state? How many are customizable in that state? Klaus Knopper's Knoppix is perhaps the best known of these distributions. Robert Bernier explains how to use Knoppix and how to customize your own self-booting distribution CD. 
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Variable Manipulation and Output  by John Coggeshall -- John Coggeshall covers basic variable manipulation and output, including math operators and strings.  
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Basic PHP Syntax  by John Coggeshall -- John Coggeshall covers basic PHP syntax, including variable usage, variable types, and how to print variables to the web browser. 
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Introduction to Socket Programming with PHP  by Daniel Solin -- Daniel Solin uses a game analogy to show how PHP can be used to exchange data between two computers using network sockets.  
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink Introduction to Socket Programming with PHP  by Daniel Solin -- Daniel Solin uses a game analogy to show how PHP can be used to exchange data between two computers using network sockets.  
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
        urlLink An Introduction to Extreme Programming  by chromatic -- When you look at it closely, Extreme Programming isn't really as extreme as it is logical. This introduction shows you the tenets of XP and its relationship to open source methods for writing software.  
       
    
    
</post>

<date>25,May,2004</date>
<post>

    
       
       Some Interesting RFC Docs need to read      2105 - Cisco Systems' Tag Switching Architecture Overview  2104 - HMAC: Keyed-hashing for Message Authentication  2095 - IMAP/POP AUTHorize Extension for Simple Challenge/Response  2085 - HMAC-MD5 IP Authentication with Replay Prevention  2083 - PNG (Portable Network Graphics) Spec. version 1.0  2082 - RIP2 MD5 Authentication  2080 - RIPng for IPv6  2069 - An Extension to HTTP: Digest Access Authentication  2068 - Hypertext Transfer Protocol -- HTTP/1.1  2058 - Remote Authentication Dial In User Service (RADIUS)  2046 - Multipurpose Internet Mail Extension (MIME) Part 2: Media Types  2045 - Multipurpose Internet Mail Extension (MIME) Part 1: Format of Internet Message Bodies    
       
    
    
</post>

<date>01,August,2004</date>
<post>

    
       
       urlLink  Haydar Linux  is full functional Arabic Linux based on Debian (?). But when I clicked on the link, there is no information where to download the link. Anybody knows where we can download it? I'll appreciate it.  Thanks. 
       
    
    
</post>

<date>01,August,2004</date>
<post>

    
       
      Feather Linux  urlLink http://featherlinux.berlios.de  is lightweight Linux that fits into 64 MB USB pendrive or half-size CD.  Try this out!
       
    
    
</post>

<date>01,August,2004</date>
<post>

    
       
       urlLink    							 						 					 		 		 urlLink Microsoft Longhorn Reinvents Desktop Graphics  	  From games to the desktop itself, 3D graphics will be everywhere in the new Windows Longhorn OS. We've got a sneak peek at the new Windows Graphics Foundation (WGF) architecture that will make it happen.
</post>

<date>01,August,2004</date>
<post>

    
       
       urlLink Linux Takes on Windows Gaming  	   Review:  Formerly known as WineX, Cedega 4.0 offers hope for Linux users who want to play graphics-heavy Windows games like Far Cry and Battlefield Vietnam. But how well does it really work -- and is it worth the monthly subscription?
</post>

<date>01,August,2004</date>
<post>

    
       
       urlLink The Evolving 3D Graphics Landscape  Graphics cards have more of an impact on overall performance than ever before, but the vast array of choices can be confusing. We help you sort through the mess and decide how much video muscle you really need.
</post>

<date>01,August,2004</date>
<post>

    
       
       urlLink The Evolving PC Audio Landscape  With Intel's HD Audio coming, Microsoft planning changes for Longhorn audio, and a software DVD-Audio shipping, PC sound is in flux. We examine the present (and future) of PC audio.   urlLink The Evolving Memory Landscape 
       
    
    
</post>

<date>01,August,2004</date>
<post>

    
       
        # A Demo for computing Polynomial. # (C) 2004, Muhammad Lutfi  # ------------ poly.h -----------------------  #ifndef POLYNOM_H #define POLYNOM_H  #define MAX_POLYNOM_ELEMENTS     250  typedef struct {    int coef;    int pow_x;    int pow_y; } PType;  typedef struct {    int     n;    PType    *poly;    //POLYNOM     *next; } POLYNOM;  typedef struct {    POLYNOM        *prev;    POLYNOM        polynom;    POLYNOM        *next; } POLYNOMLIST;   #endif # ------------------ end of poly.h ----------------------------  #------- poly.c ------------------ #include   #include   #include   #include "poly.h"  const char *delim = " ";  int Polynom_GetInput(POLYNOM *plnm) {    char buf[1024];    int i,j,n;    div_t divr;    char *p;    int a[3*MAX_POLYNOM_ELEMENTS];      //printf("Enter your polynomial variables (it is sequence of triples: c pow_x pow_y)\n");    printf("Enter Polynoms = ");    gets(buf);    if (strlen(buf) == 0) {        plnm->n = 0;        plnm->poly = NULL;        return 0;    }    n = 0;    if ((p=strtok(buf, delim)) != NULL) {        // found the first input        n=1;        a[0] = atoi(p);    }    while ((p=strtok(NULL, delim)) != NULL &&amp; n  0) {        /* that's all the input.  Now, ensure the input is repetition of triplets        */        divr = div(n,3);        if (divr.rem == 0) {        // yes, it is a sequence of triplet            plnm->poly = (PType*)malloc(n/3 * sizeof(PType));            if (plnm->poly == NULL)                exit(1);            plnm->n = n/3;            for(i=0; i  poly[j].coef = a[i];                    plnm->poly[j].pow_x = a[i+1];                    plnm->poly[j].pow_y = a[i+2];                }            }            return 1;        }    }    return 0; }  int Polynom_Copy(const POLYNOM *src, POLYNOM *dest) {    // destination polynom should not NULL    if (src==NULL || dest==NULL) return 0;    dest->poly = (PType *)malloc(src->n * sizeof(PType));    if (dest->poly) {        memcpy(dest->poly, src->poly, src->n * sizeof(PType));        return 1;    }    return 0; }   void Polynom_Free(POLYNOM *p) {    if (!p) return;    if (p->poly) {        free(p->poly);        p->n = 0;        p->poly = NULL;    } }   void Polynom_Print(const POLYNOM *p) {    int i;    char strc[50], strx[50], stry[50];    short sign;    char strsign[5];    short first_time=1;    int coef;      if (!p) return;    strx[0] = '\0';    stry[0] = '\0';    for(i=0; i n; i++) {        coef = p->poly[i].coef;        // ignore coef=0        // using temporary var for sign is slightly faster than accessing structure of pointer p        if (coef != 0) {            sign = ( coef  poly[i].pow_x !=0 || p->poly[i].pow_y !=0))                strcpy(strc, strsign);            else                sprintf(strc, "%s%0d", strsign, abs(coef));            if (p->poly[i].pow_x == 0)                strcpy(strx, "");            else if (p->poly[i].pow_x == 1)                strcpy(strx, "x");            else                sprintf(strx, "x^%-d", p->poly[i].pow_x);            if (p->poly[i].pow_y == 0)                strcpy(stry, "");            else if (p->poly[i].pow_y == 1)                strcpy(stry, "y");            else                sprintf(stry, "y^%-d", p->poly[i].pow_y);            //sprintf("%u%s%s");            printf("%s%s%s", strc, strx, stry);        }    }    printf("\n"); }   int Polynom_Add(PType *result, const PType P1, const PType P2) {    if (result == NULL)        return 0;    if ((P1.pow_x == P2.pow_x) &&amp; (P1.pow_y == P2.pow_y)) {        // p1 & p2 have the same order of x,y        result->coef = P1.coef + P2.coef;        return 1;      }    else {        return 0;    } }  void Polynom_Simplify(POLYNOM *p1, POLYNOM *p2) {    int i,j,k;     }   int main(int argc, char *argv[]) {    POLYNOM p1;    int i=0;      while (Polynom_GetInput(&p1)) {        //for(i=0; i         
       
    
    
</post>


</Blog>