<Blog>

<date>22,July,2004</date>
<post>

	 
      In my last blog, I had had pointed out a suggestion that a firm primarily exists because of the existence of marketing costs. But then a firm could keep growing and growing eliminating all market transactions. Obviously, there have to be certain reasons why this does not happen.  1) As the firm gets larger, the cost of doing transactions within the firm will increase rather than increase, as predicted. A point will be reached where the costs of organizing an extra transaction within the organization is equal to the costs involved in doing the same transactions in the open market. It could also be that another entrepreneur would be doing the same transaction at a lower cost.  2) As the firm grows larger, the value drawn from the factors of production is not maximized. The entrepreneur may fail to make the best use of the factors of production. In other words, a point will be reached when the loss on the firm through the wastage of resources is is equal to the marketing costs of the exchange transactions in the open market or by that being done by another entrepreneur.  In effect, the firm will expand till the cost of doing any extra transaction within the firm equals the cost of doing the same thing in the open market.  An interesting exception to the other rule is the combination of two such firms. A firm should only take over another whole organization only if the latters cost of doing a transaction and the cost of doing the transaction on the open market is less than the cost of the former doing it.  Other things being equal, a firm will tend to be larger  1) if the cost of organizing a transaction is lesser and the rate of change of these costs will increase with the increase in the transactions organized. 2) if the entrepreneur is less likely to make mistakes and the rate of increase of these mistakes decreases with the transactions organized within the firm. 3) if the cost of supplying factors of production to firms of larger size does not increase at a rapid rate.  This does tend to concur with our observations that larger firms tend to be inefficient within, however are able to compensate the same by commanding lesser transaction costs in the open market (they manage to sell by sheer size, or branding, etc.) 
    
</post>

<date>17,July,2004</date>
<post>

	 
      Most of us know that the economy exists because of the competing forces of supply and demand. But seldom have we questioned as to why it would be necessary to have organizations/firms in order to do the production? Outside of the firm, price movements direct production, which is coordinated through a series of transactions in the market. However, inside the firm, these transactions are eliminated and are instead replaced by an enterpreneur-coordinator who directs production. R.H.Coase was the first to ask such a question, and his theories became the foundation of what is called Coasian Economics. He asked: "If production is regulated by price movements, production could be carried on without any organization at all, in which case, why is there any organization at all?"  The main reason why it would be profitable to establish a firm would be that there is a cost of using the price mechanism. Every transaction in the economy must be performed at a cost. It would be far more favourable if the transaction costs that are incurred in this manner be minimized. There could be two approaches to doing that. One, employ the services of specialists who would enter into a  contract  with the producer, thereby replacing multiple transactions by one, and the second, to employ certain factors who would agree to agree to obey the instructions of the enterpreneur within certain limits for a certain renumeration. Such a contract should only state the limits of the powers of the enterpreneur; within these limits, he can therefore direct the other factors of production.  Also, owing to the dificulty of forecasting, the longer the period of a contract for the supply of a commodity or service, the less possible and indeed desirable it is for a the purchaser to specify what the contractor can and should do. A firm is likely to emerge in those cases where a very short term contract is likely to be satisfactory. To sum it up, the operation of a market costs something and by forming an organization and allowing some authority (an "enterpreneur") to direct the resources, such costs can be saved. The enterpreneur has to carry our his function at less cost, taking into account the fact that he may get the factors of production at a lower price than the market cost he is trying to overcome. If not, he can always revert back to the open market if he fails to do this. The interesting thing is that without the uncertainty factor, a firm would probably not arise.  An enterpreneur may also be defined as a person who takes the residual and fluctuating income from production while the employees engaged in production take a fixed income. However this may not seem to be the reason for the formation of a firm, as the profits may be shared by the employees.  
    
</post>

<date>16,July,2004</date>
<post>

	 
      In an attempt to broaden my horizons and my thinking, I will attempt to write articles and my opinions on topics that I find at random. The strength of an argument depends solely on data and is supported only by strong writing skills. Hopefully I will be able to present convincing data!  In the 15th Century, Christopher Columbus sailed the seas in search of sea routes to the east seeking spice. He discovered an entirely new continent in the process. That continent now houses one of the most powerful nations in the world. Today the search continues. Man is reached deep into space. Space probes have ventured into the boundaries of our solar systems. Man has already gained command over landing on the moon. He is trying to reach the next planet: Mars. Who knows what such a search may yield. It may not sound very convincing today, but it's a bet that over time will yield benefits far greater than those that can be imagined. Man should never give up pushing frontiers trying to reach planets.  What is it that separates this species of the Hominids from the other species on the planet? He thrives on challenge. It is the challenge that causes him to focus all his faculties on achieving a goal. He builds from dreams and concepts, failure to him becomes the stepping stone to success. It is his will to achieve higher and higher ambitions that given him the power to be the dominant species on earth. Even though improving conditions on earth is important, it should not be a deterrent to achieving loftier ambitions. It holds several economic, strategic and sociological implications, with far reaching outcomes.  Trying to reach other planets is symbolic of human nature to innovate. Innovation is a prime mover for various spheres of life, whether it is business, politics or society. It acts as a catalyst, transforming our very lives. Innovation can be of two types: sustaining and disruptive. Sustaining innovations such as improvements made to methodologies used to improve agricultural output have contributed significantly to our quality of life. On the other hand, it is the disruptive innovations that have the maximum impact on our society. The study of genetics, for example, holds the key to disruptively enable us to solve our food problems, giving us a totally different approach to solving the age-old problem. Totally unrelated innovations in the study of the molecular biology have led us to the brink of quadrupling agricultural output. Trying to reach the moon was a disruptive innovation, as is trying to reach Mars today. In trying to do so, it has opened innovation in several dimensions. It may not help us improve the conditions on earth immediately, but it will help us to reap unfathomable benefits. A cat in a box will never know what lies outside the box till it tries to jump out of the box. Innovation should never be stemmed. It contains the key to survivability.  Even so, the space program has yielded several direct benefits, both tangible and intangible. It provides several spin-offs to the economy. It has affected diverse areas of our general well being from the medical sciences to public safety. It has yielded several technological innovations, with little fanfare, which have affected the way we live. Temper foam, for example, used in helmets, airline seats, crash protection equipment, is an offshoot from the American Space Program. Laser Angioplasty, which saves many lives daily, owes its origins to technological breakthroughs made during the attempt to reach the moon. Communication as we know it today would not have existed had it not been for satellites, which orbit the earth: TV, mobile communications, Global Positioning Systems all owe their origin to space related technologies. Weather prediction, resource mining, all owe a lot to man's strife to surpass the boundaries of the globe. Space related technological has helped countries lead in global markets. It has several tangible benefits to the quality of life experienced by humankind. It is said that money spent on the American Space Program has yielded returns at about the same rate as expenditure on any other government expenditure. It provides employment to many. It provides the industry with a rich talent pool, something that one cannot do without.  Indeed, the drive to reach other planets is a force to reckon with. It reflects the indomitable spirit of man, his constant thirst for challenge and his ability to reap benefits from the results. Would it be wise to focus entirely on one sphere of human life (improving conditions on earth) and ignore the other?
    
</post>

<date>15,July,2004</date>
<post>

	 
      Why are there so many ways to say no, yet so little to say yes! The human minds it seems is more geared to critically analyze issues rather than see the light. Every argument is based on some premises and some assumptions. There are no conclusions without any assumptions... it is always possible to completely bring down an argument. However it is so dificult to actually come up with an issue and see it through. There is ALWAYS a better way, there is ALWAYS something wrong. It is indeed dificult to scavenge through the talk and come up with a winner.
    
</post>

<date>15,July,2004</date>
<post>

	 
      If something is the Bee's Knees, its the very best or desirable. This strange expression is one of those many that emerged during the 1920's "flapper" period when anything excellent was likely to to receive a catchphrase having to do something with some animal part. So expect the bee's knees
    
</post>


<date>30,July,2004</date>
<post>

     
      Ever wondered how to display console output in colors? If you've seen the Linux's verbose bootup sequence, you will notice the variety of colors that are used in the console output.  How the hell do you get the same in Windows based console applications? The guys are Redmond haven't left this feature out.  The Windows Platform SDK includes several functions for console manipulation. I will outline some functions that may be used to alter output to the console. The primary function to be used is  SetConsoleTextAttribute()  If you're going to use the SDK directly, this is the definition you'd be interested in:     BOOL SetConsoleTextAttribute( HANDLE hConsoleOutput, WORD wAttributes )    Unfortunately, in the managed world, no APIs are directly available. They will have to be invoked via P/Invoke. There is an posting on CodeProject by Philip Fitzsimons for this purpose. ( urlLink here )  There is one missing feature in the source he provides: Many of us customize our consoles to suit our purpose; many a times changing our console foreground and background colors. In his call to  SetForeGroundColor()  which he uses to reset the console, he just sets the foreground color of the console to Grey.  A better way would be to convert his entire class to an instance and convert all his methods into instance methods rather than static methods. In the constructor, you could use an Interop call to:     [DllImport("kernel32.dll")] static extern bool GetConsoleScreenBufferInfo(IntPtr hConsoleOutput, out CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);     Of course, you would need to write the C# equivalent for the structure  CONSOLE_SCREEN_BUFFER_INFO . The structure contains the character attributes for the console. Store these within your instance, and just revert to the same character attributes with a call to  SetConsoleTextAttribute()  after doing your custom formatting.  There is a managed C++ sample to do the same  urlLink here   There is still nothing as good as a console program to do some tasks!
     
    
</post>

<date>20,July,2004</date>
<post>

     
      WordIQ defines a "Software Engineering" as the profession concerned with the creation and maintenance of software applications by APPLYING Computer Science, Project Management, Domain Knowledge and other skills and technologies. It is not enough to just write efficient, bug free programs to be a Software Engineer. A software engineer in the true sense should be able to unify programming knowledge (which should serve no more than as tools), with a comprehensive body of knowledge on Computer Science, Mathematics, and many other areas and apply suitable Project Management Techniques to make sure the development is effective. In some specialized areas, such as Medical Imaging, Biotechnology (which are emerging areas today), he/she needs to acquire domain knowledge, translate that into tools which can be used by already skilled people in those domains in order to help them improve their abilities and productivity.  A programmer on the other hand just needs to churn out code.  When I say that a software engineer should consider programming languages and related technologies as tools, I do not mean that one should ignore them. He/she has to know the tools that he/she needs to work with. Knowledge of the tools can help him decide which one is best suited for the job. The old adage says productivity = (skills)^tools, so tools are an extremely important aspect of developing software, something that can improve performance exponentially.  However, there needs to be note of caution. Learning a new tool takes time, and overall usage matures over time. So I do not think it very wise to jump in and learn every new tool that you come across. One should definitely not do it just for learnability's sake. If you feel you have all the tools at your disposal, please use them, instead of trying to master something new, just because its news (and somehow better, they all claim they are!)  There is indeed another caveat that software engineers fall into. Its called PROCESS. There are invariably too many "process gurus" within a company, each with their own very strong belief about which process is correct. A process should be tailored to the kind of development you need to have, which to some extent should depend on how fluid your development is going to be over time and what your customer expects. (If he expects, for example frequent releases, or for example is evaluating a product before purchasing is very vocal in pointing out bugs, the a continuous integration process would be quite suitable. For more control-based organizations, where there needs to be strict control on the features a product needs to have, or there is a huge separation between the analysts and developers, something like a waterfall would be more suitable. (I only provide examples, I do not want a flurry of angry emails suggesting which process is better for what!! :) ). For many companies, the process model followed by them (and as accredited by certifications) proves as a benchmark for customers as to how healthy the development within the organization is. For such companies, having these processes does make sense.  But one seldom remembers, both the above are only accessories. The customer does not care about anything other than the features the product has and how good the support is. In my opinion, one should try and stay as fluid as possible. I don't remember anybody gaining anything by having heavyweight processes in place.  The core job of a software engineer in my opinion is to bridge the gap between technology and a customer's requirement. The customer, many a times, will not know that he has a requirement! Sometimes, the software engineer will be as much a contributor to requirements as the customer himself, and that is, in my opinion, the healthy way of developing software. Sometimes a customer may think a problem unsolvable, which happens often in the image processing space, for example, but on interfacing with a software engineer, may discover infact that it is.
     
    
</post>

<date>17,July,2004</date>
<post>

     
      An AppDomain was a concept created in .NET to provide isolation within the context of a worker process. In the case of IIS 5, a single worker process (aspnet_wp.exe) is maintained for  all web sites , except in the case of web gardens, which may have more. In the case of IIS 6, a worker process (w3wp.exe) is maintained for an  application pool . To improve performance, web sites share this worker process, with the separation provided by a  logical process  within the process called an AppDomain.    Using .NET Remoting components from an ASP.NET application or IIS Hosted remote object    ASP.NET uses an AppDomain for each ASP.NET web site. This AppDomain contains the Application, Cache and in-process Session objects for the site. The situation is not very different for .NET remoting objects hosted on IIS. It is very easy to concieve single-call objects hosted in IIS to be new object instances in a totally different AppDomain, whereas the case is not so.  Consider the case: You have a .NET remoting object hosted in IIS which accesses another object through remoting. A common error one would make would be to register a channel on each invocation of the hosted object. This is likely to throw up a " channel x already registered " exception.  ChannelServices.RegisterChannel()  throws a RemotingException with the above message since a channel with the same name would have already been registered in a previous call. A channel needs to be unique by name to be registered in an AppDomain. Since only one AppDomain exists for the web site, unless recycled, you should instead check if the channel already exists prior to registering the channel with   GetChannel() .  The situation is slightly more complicated in the case of ASP.NET. If you plan to use a .NET Remote component from an ASP.NET page, you must establish the remoting configuration for the client at application start, using the  Application_Start  event in the  global.asax  file. When using  RemotingConfiguration.Configure() , you also need to very careful about the location of the configuration file. The HttpRequest will only see the virtual directory, and NOT the absolute path. However this can be circumvented using the  HttpRequest.MapPath()  method to obtain the full path to the configuration path. A similar technique can be used to setup the remoting configuration for .NET remoting objects hosted in IIS (ie via a  global.asax )  The no of AppDomains an process can contain can easily be determined by using  enumappdomains  utility.    How IIS processes requests    Process creation can be of two types: Manual and Automatic. Managed Console and Windows Forms applications comprise the former type. The latter are more tricky to deal with and consist of: 1) Managed Windows Service applications 2) Enterprise Services (COM+ including Queued Components) 3) IIS/ASP.NET We shall deal with only (3)  ASP.NET/IIS exhibits on-demand startup. They are started only when a request comes in. A request comes in through HTTP.SYS and gets queued. A control message gets sent to the WAS (W3SVC) which spins up the worker process if it is not already running. The worker process (aspnet_wp.exe or w3wp.exe) contains the appdomain for the request which fetches the request from the queue and processes it. All future requests are then routed to the AppDomain via HTTP.SYS and worker process. There is one AppDomain per application as stated earlier. Process pooling is available for ASP.NET. A process from the pool is assigned to requests in a round robin fashion and then the remains for the lifetime of the connection. Thread pooling is also available. In case of long running threads, ASP.NET kills the thread to give other request a chance. The worker process contains a thread pool of 20 by default. Once the request queue starts filling up ASP.NET starts rejecting further requests.  If a long running work item is unavoidable, it is advisable to store them in a queue and let them be processed by an application hosted in Enterprise Services or Windows Services.  How then does ASP.NET permit debugging? ASP.NET has an orphan mode where processes aren't recycled! This mode is used for debugging.  A comparison between Windows Services, Enterprise Services and ASP.NET is due... :) I shall try and cover it later.    AppDomain Recycling    Sometimes it becomes necessary to recycle an ASP.NET AppDomain without killing the worker process (it would kill the other AppDomains). Even during development, changes to shared assemblies and or other files is not uncommon. Since the CLR binds to assemblies at application start time, updates to assemblies will go unnoticed. The config files however are monitored for changes. Changes to a web application's web.config file causes the AppDomain running that application to undergo recycling. Simply "touching" the web.config will have the desired effect without killing the worker process. The same can be achieved by "touching" machine.config. However in this case, all AppDomains in the worker process will be recycled. A note of caution: you will obviously loose all Application, Cache and Session information! 
     
    
</post>

<date>16,July,2004</date>
<post>

     
      The technology industry is becoming more like a fishmarket. Vendors offer all sorts, shapes and sizes of fish, each one claiming their own superiority over the other, haggling fiercely to get a share of the pie. Here are my observations and titbits on fish... the irony is that I am a vegetarian. No one better than an outsider to give you a different perspective! The time has come to strictly fragment the software industry into the programming and the engineering industry. Everybody claims to be an expert in their areas. I strictly believe on concentrating on the basics. Why keep going round and round in circles? Whatever I learn today will anyway become obsolete tomorrow. Instead, some basic concepts always remain the same, those are the things to concentrate on. The rest can be interpolated on at a given time. In this blog I will mostly concentrate on the things that need to be investigated from time to time and then forget over time, since something else would have replaced it. However, I may, occasionally, touch upon topics that are invariant.
     
    
</post>

<date>04,August,2004</date>
<post>

     
      The technique I'd like to cover today is a technique used to perform loop unrolling. Loops are often a good candidate for optimization. Do while loops, while loops, for-next loops all have a fairly similar structure: the provide a body of code to be executed within the loop, often with code that is dependent on the loop cycle (ie dependent on the variable used as the counter for the loop), and start and end conditions for the loop. Loops which are candidates for the use of Duff's device, may have a body which may or may not depend on the counter variable.  Lets take an example: How would one write code that copies one chunk of data into another? Typically, this is how it would be written:     send(to, from, count) { &nbsp;&nbsp;&nbsp;&nbsp;do &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(--count>0); }     Let me ignore things such as bounds checking for the pointers, etc for now. (They are, however, extremely important) When the above piece of code gets translated into machine code, the body gets converted into a chunk of code, as does the condition checking and is followed by a JMP instruction. Typically, the JMP instruction, confuses the branch prediction logic in the processor, causes it to clear its instruction prefetch cache, and also, inhibit pipelining.  One very creative way of doing the same thing without the disadvantages listed above is the Duff's device:     send(to, from, count) { &nbsp;&nbsp;&nbsp;&nbsp;register n=(count+7)/8; &nbsp;&nbsp;&nbsp;&nbsp;switch(count%8){ &nbsp;&nbsp;&nbsp;&nbsp;case 0:&nbsp;do{&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;case 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*to = *from++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while(--n>0); &nbsp;&nbsp;&nbsp;&nbsp;} }    This is, in my opinion, a brilliant way to achieve optimization. It does not matter which coding language you use, some people use in their Javascript, others in C, the effect of the optimization is quite aparent.  Try and understand what the code does! The value of n does not have to be the ceiling of the count by 8, it may be by 4, or any other no for that matter. However the no of cases arising would be equivalent. Also, not that each of the case statements allow the call flow to fall through, rather than break. You can put almost any logic in each of the case bodies, it does not matter. It will of course lead to a little code expansion, but the trade-off will be quite favourable. 
     
    
</post>


</Blog>